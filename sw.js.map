{"mappings":"C,A,W,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,U,C,E,O,C,C,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,Q,S,C,C,C,E,E,E,O,C,W,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,Y,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,W,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,W,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,gB,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,a,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,W,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,qD,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,e,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,gB,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,gB,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,gB,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,Y,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,a,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,iB,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,O,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,O,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,kB,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,e,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,c,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,a,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,gB,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,mB,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,Y,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,Q,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,sB,W,O,C,E,S,C,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","sources":["<anon>","node_modules/react/cjs/react.production.min.js","node_modules/@parcel/service-worker/runtime-8e7133a7b359b20b.js","node_modules/@parcel/service-worker/service-worker.js","src/sw.ts","src/ts/helpers/storage.tsx","node_modules/localforage/dist/localforage.js","node_modules/react/index.js"],"sourcesContent":["(function () {\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire194d\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire194d\"] = parcelRequire;\n}\nparcelRequire.register(\"enmjz\", function(module, exports) {\n\n$parcel$export(module.exports, \"Children\", function () { return $a77485e72fcbbe24$export$dca3b0875bd9a954; }, function (v) { return $a77485e72fcbbe24$export$dca3b0875bd9a954 = v; });\n$parcel$export(module.exports, \"Component\", function () { return $a77485e72fcbbe24$export$16fa2f45be04daa8; }, function (v) { return $a77485e72fcbbe24$export$16fa2f45be04daa8 = v; });\n$parcel$export(module.exports, \"Fragment\", function () { return $a77485e72fcbbe24$export$ffb0004e005737fa; }, function (v) { return $a77485e72fcbbe24$export$ffb0004e005737fa = v; });\n$parcel$export(module.exports, \"Profiler\", function () { return $a77485e72fcbbe24$export$e2c29f18771995cb; }, function (v) { return $a77485e72fcbbe24$export$e2c29f18771995cb = v; });\n$parcel$export(module.exports, \"PureComponent\", function () { return $a77485e72fcbbe24$export$221d75b3f55bb0bd; }, function (v) { return $a77485e72fcbbe24$export$221d75b3f55bb0bd = v; });\n$parcel$export(module.exports, \"StrictMode\", function () { return $a77485e72fcbbe24$export$5f8d39834fd61797; }, function (v) { return $a77485e72fcbbe24$export$5f8d39834fd61797 = v; });\n$parcel$export(module.exports, \"Suspense\", function () { return $a77485e72fcbbe24$export$74bf444e3cd11ea5; }, function (v) { return $a77485e72fcbbe24$export$74bf444e3cd11ea5 = v; });\n$parcel$export(module.exports, \"__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\", function () { return $a77485e72fcbbe24$export$ae55be85d98224ed; }, function (v) { return $a77485e72fcbbe24$export$ae55be85d98224ed = v; });\n$parcel$export(module.exports, \"cloneElement\", function () { return $a77485e72fcbbe24$export$e530037191fcd5d7; }, function (v) { return $a77485e72fcbbe24$export$e530037191fcd5d7 = v; });\n$parcel$export(module.exports, \"createContext\", function () { return $a77485e72fcbbe24$export$fd42f52fd3ae1109; }, function (v) { return $a77485e72fcbbe24$export$fd42f52fd3ae1109 = v; });\n$parcel$export(module.exports, \"createElement\", function () { return $a77485e72fcbbe24$export$c8a8987d4410bf2d; }, function (v) { return $a77485e72fcbbe24$export$c8a8987d4410bf2d = v; });\n$parcel$export(module.exports, \"createFactory\", function () { return $a77485e72fcbbe24$export$d38cd72104c1f0e9; }, function (v) { return $a77485e72fcbbe24$export$d38cd72104c1f0e9 = v; });\n$parcel$export(module.exports, \"createRef\", function () { return $a77485e72fcbbe24$export$7d1e3a5e95ceca43; }, function (v) { return $a77485e72fcbbe24$export$7d1e3a5e95ceca43 = v; });\n$parcel$export(module.exports, \"forwardRef\", function () { return $a77485e72fcbbe24$export$257a8862b851cb5b; }, function (v) { return $a77485e72fcbbe24$export$257a8862b851cb5b = v; });\n$parcel$export(module.exports, \"isValidElement\", function () { return $a77485e72fcbbe24$export$a8257692ac88316c; }, function (v) { return $a77485e72fcbbe24$export$a8257692ac88316c = v; });\n$parcel$export(module.exports, \"lazy\", function () { return $a77485e72fcbbe24$export$488013bae63b21da; }, function (v) { return $a77485e72fcbbe24$export$488013bae63b21da = v; });\n$parcel$export(module.exports, \"memo\", function () { return $a77485e72fcbbe24$export$7c73462e0d25e514; }, function (v) { return $a77485e72fcbbe24$export$7c73462e0d25e514 = v; });\n$parcel$export(module.exports, \"startTransition\", function () { return $a77485e72fcbbe24$export$7568632d0d33d16d; }, function (v) { return $a77485e72fcbbe24$export$7568632d0d33d16d = v; });\n$parcel$export(module.exports, \"unstable_act\", function () { return $a77485e72fcbbe24$export$88948ce120ea2619; }, function (v) { return $a77485e72fcbbe24$export$88948ce120ea2619 = v; });\n$parcel$export(module.exports, \"useCallback\", function () { return $a77485e72fcbbe24$export$35808ee640e87ca7; }, function (v) { return $a77485e72fcbbe24$export$35808ee640e87ca7 = v; });\n$parcel$export(module.exports, \"useContext\", function () { return $a77485e72fcbbe24$export$fae74005e78b1a27; }, function (v) { return $a77485e72fcbbe24$export$fae74005e78b1a27 = v; });\n$parcel$export(module.exports, \"useDebugValue\", function () { return $a77485e72fcbbe24$export$dc8fbce3eb94dc1e; }, function (v) { return $a77485e72fcbbe24$export$dc8fbce3eb94dc1e = v; });\n$parcel$export(module.exports, \"useDeferredValue\", function () { return $a77485e72fcbbe24$export$6a7bc4e911dc01cf; }, function (v) { return $a77485e72fcbbe24$export$6a7bc4e911dc01cf = v; });\n$parcel$export(module.exports, \"useEffect\", function () { return $a77485e72fcbbe24$export$6d9c69b0de29b591; }, function (v) { return $a77485e72fcbbe24$export$6d9c69b0de29b591 = v; });\n$parcel$export(module.exports, \"useId\", function () { return $a77485e72fcbbe24$export$f680877a34711e37; }, function (v) { return $a77485e72fcbbe24$export$f680877a34711e37 = v; });\n$parcel$export(module.exports, \"useImperativeHandle\", function () { return $a77485e72fcbbe24$export$d5a552a76deda3c2; }, function (v) { return $a77485e72fcbbe24$export$d5a552a76deda3c2 = v; });\n$parcel$export(module.exports, \"useInsertionEffect\", function () { return $a77485e72fcbbe24$export$aaabe4eda9ed9969; }, function (v) { return $a77485e72fcbbe24$export$aaabe4eda9ed9969 = v; });\n$parcel$export(module.exports, \"useLayoutEffect\", function () { return $a77485e72fcbbe24$export$e5c5a5f917a5871c; }, function (v) { return $a77485e72fcbbe24$export$e5c5a5f917a5871c = v; });\n$parcel$export(module.exports, \"useMemo\", function () { return $a77485e72fcbbe24$export$1538c33de8887b59; }, function (v) { return $a77485e72fcbbe24$export$1538c33de8887b59 = v; });\n$parcel$export(module.exports, \"useReducer\", function () { return $a77485e72fcbbe24$export$13e3392192263954; }, function (v) { return $a77485e72fcbbe24$export$13e3392192263954 = v; });\n$parcel$export(module.exports, \"useRef\", function () { return $a77485e72fcbbe24$export$b8f5890fc79d6aca; }, function (v) { return $a77485e72fcbbe24$export$b8f5890fc79d6aca = v; });\n$parcel$export(module.exports, \"useState\", function () { return $a77485e72fcbbe24$export$60241385465d0a34; }, function (v) { return $a77485e72fcbbe24$export$60241385465d0a34 = v; });\n$parcel$export(module.exports, \"useSyncExternalStore\", function () { return $a77485e72fcbbe24$export$306c0aa65ff9ec16; }, function (v) { return $a77485e72fcbbe24$export$306c0aa65ff9ec16 = v; });\n$parcel$export(module.exports, \"useTransition\", function () { return $a77485e72fcbbe24$export$7b286972b8d8ccbf; }, function (v) { return $a77485e72fcbbe24$export$7b286972b8d8ccbf = v; });\n$parcel$export(module.exports, \"version\", function () { return $a77485e72fcbbe24$export$83d89fbfd8236492; }, function (v) { return $a77485e72fcbbe24$export$83d89fbfd8236492 = v; });\n/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var $a77485e72fcbbe24$export$dca3b0875bd9a954;\nvar $a77485e72fcbbe24$export$16fa2f45be04daa8;\nvar $a77485e72fcbbe24$export$ffb0004e005737fa;\nvar $a77485e72fcbbe24$export$e2c29f18771995cb;\nvar $a77485e72fcbbe24$export$221d75b3f55bb0bd;\nvar $a77485e72fcbbe24$export$5f8d39834fd61797;\nvar $a77485e72fcbbe24$export$74bf444e3cd11ea5;\nvar $a77485e72fcbbe24$export$ae55be85d98224ed;\nvar $a77485e72fcbbe24$export$e530037191fcd5d7;\nvar $a77485e72fcbbe24$export$fd42f52fd3ae1109;\nvar $a77485e72fcbbe24$export$c8a8987d4410bf2d;\nvar $a77485e72fcbbe24$export$d38cd72104c1f0e9;\nvar $a77485e72fcbbe24$export$7d1e3a5e95ceca43;\nvar $a77485e72fcbbe24$export$257a8862b851cb5b;\nvar $a77485e72fcbbe24$export$a8257692ac88316c;\nvar $a77485e72fcbbe24$export$488013bae63b21da;\nvar $a77485e72fcbbe24$export$7c73462e0d25e514;\nvar $a77485e72fcbbe24$export$7568632d0d33d16d;\nvar $a77485e72fcbbe24$export$88948ce120ea2619;\nvar $a77485e72fcbbe24$export$35808ee640e87ca7;\nvar $a77485e72fcbbe24$export$fae74005e78b1a27;\nvar $a77485e72fcbbe24$export$dc8fbce3eb94dc1e;\nvar $a77485e72fcbbe24$export$6a7bc4e911dc01cf;\nvar $a77485e72fcbbe24$export$6d9c69b0de29b591;\nvar $a77485e72fcbbe24$export$f680877a34711e37;\nvar $a77485e72fcbbe24$export$d5a552a76deda3c2;\nvar $a77485e72fcbbe24$export$aaabe4eda9ed9969;\nvar $a77485e72fcbbe24$export$e5c5a5f917a5871c;\nvar $a77485e72fcbbe24$export$1538c33de8887b59;\nvar $a77485e72fcbbe24$export$13e3392192263954;\nvar $a77485e72fcbbe24$export$b8f5890fc79d6aca;\nvar $a77485e72fcbbe24$export$60241385465d0a34;\nvar $a77485e72fcbbe24$export$306c0aa65ff9ec16;\nvar $a77485e72fcbbe24$export$7b286972b8d8ccbf;\nvar $a77485e72fcbbe24$export$83d89fbfd8236492;\n\"use strict\";\nvar $a77485e72fcbbe24$var$l = Symbol.for(\"react.element\"), $a77485e72fcbbe24$var$n = Symbol.for(\"react.portal\"), $a77485e72fcbbe24$var$p = Symbol.for(\"react.fragment\"), $a77485e72fcbbe24$var$q = Symbol.for(\"react.strict_mode\"), $a77485e72fcbbe24$var$r = Symbol.for(\"react.profiler\"), $a77485e72fcbbe24$var$t = Symbol.for(\"react.provider\"), $a77485e72fcbbe24$var$u = Symbol.for(\"react.context\"), $a77485e72fcbbe24$var$v = Symbol.for(\"react.forward_ref\"), $a77485e72fcbbe24$var$w = Symbol.for(\"react.suspense\"), $a77485e72fcbbe24$var$x = Symbol.for(\"react.memo\"), $a77485e72fcbbe24$var$y = Symbol.for(\"react.lazy\"), $a77485e72fcbbe24$var$z = Symbol.iterator;\nfunction $a77485e72fcbbe24$var$A(a) {\n    if (null === a || \"object\" !== typeof a) return null;\n    a = $a77485e72fcbbe24$var$z && a[$a77485e72fcbbe24$var$z] || a[\"@@iterator\"];\n    return \"function\" === typeof a ? a : null;\n}\nvar $a77485e72fcbbe24$var$B = {\n    isMounted: function() {\n        return !1;\n    },\n    enqueueForceUpdate: function() {},\n    enqueueReplaceState: function() {},\n    enqueueSetState: function() {}\n}, $a77485e72fcbbe24$var$C = Object.assign, $a77485e72fcbbe24$var$D = {};\nfunction $a77485e72fcbbe24$var$E(a, b, e) {\n    this.props = a;\n    this.context = b;\n    this.refs = $a77485e72fcbbe24$var$D;\n    this.updater = e || $a77485e72fcbbe24$var$B;\n}\n$a77485e72fcbbe24$var$E.prototype.isReactComponent = {};\n$a77485e72fcbbe24$var$E.prototype.setState = function(a, b) {\n    if (\"object\" !== typeof a && \"function\" !== typeof a && null != a) throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n    this.updater.enqueueSetState(this, a, b, \"setState\");\n};\n$a77485e72fcbbe24$var$E.prototype.forceUpdate = function(a) {\n    this.updater.enqueueForceUpdate(this, a, \"forceUpdate\");\n};\nfunction $a77485e72fcbbe24$var$F() {}\n$a77485e72fcbbe24$var$F.prototype = $a77485e72fcbbe24$var$E.prototype;\nfunction $a77485e72fcbbe24$var$G(a, b, e) {\n    this.props = a;\n    this.context = b;\n    this.refs = $a77485e72fcbbe24$var$D;\n    this.updater = e || $a77485e72fcbbe24$var$B;\n}\nvar $a77485e72fcbbe24$var$H = $a77485e72fcbbe24$var$G.prototype = new $a77485e72fcbbe24$var$F;\n$a77485e72fcbbe24$var$H.constructor = $a77485e72fcbbe24$var$G;\n$a77485e72fcbbe24$var$C($a77485e72fcbbe24$var$H, $a77485e72fcbbe24$var$E.prototype);\n$a77485e72fcbbe24$var$H.isPureReactComponent = !0;\nvar $a77485e72fcbbe24$var$I = Array.isArray, $a77485e72fcbbe24$var$J = Object.prototype.hasOwnProperty, $a77485e72fcbbe24$var$K = {\n    current: null\n}, $a77485e72fcbbe24$var$L = {\n    key: !0,\n    ref: !0,\n    __self: !0,\n    __source: !0\n};\nfunction $a77485e72fcbbe24$var$M(a, b, e) {\n    var d, c = {}, k = null, h = null;\n    if (null != b) for(d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = \"\" + b.key), b)$a77485e72fcbbe24$var$J.call(b, d) && !$a77485e72fcbbe24$var$L.hasOwnProperty(d) && (c[d] = b[d]);\n    var g = arguments.length - 2;\n    if (1 === g) c.children = e;\n    else if (1 < g) {\n        for(var f = Array(g), m = 0; m < g; m++)f[m] = arguments[m + 2];\n        c.children = f;\n    }\n    if (a && a.defaultProps) for(d in g = a.defaultProps, g)void 0 === c[d] && (c[d] = g[d]);\n    return {\n        $$typeof: $a77485e72fcbbe24$var$l,\n        type: a,\n        key: k,\n        ref: h,\n        props: c,\n        _owner: $a77485e72fcbbe24$var$K.current\n    };\n}\nfunction $a77485e72fcbbe24$var$N(a, b) {\n    return {\n        $$typeof: $a77485e72fcbbe24$var$l,\n        type: a.type,\n        key: b,\n        ref: a.ref,\n        props: a.props,\n        _owner: a._owner\n    };\n}\nfunction $a77485e72fcbbe24$var$O(a) {\n    return \"object\" === typeof a && null !== a && a.$$typeof === $a77485e72fcbbe24$var$l;\n}\nfunction $a77485e72fcbbe24$var$escape(a) {\n    var b = {\n        \"=\": \"=0\",\n        \":\": \"=2\"\n    };\n    return \"$\" + a.replace(/[=:]/g, function(a) {\n        return b[a];\n    });\n}\nvar $a77485e72fcbbe24$var$P = /\\/+/g;\nfunction $a77485e72fcbbe24$var$Q(a, b) {\n    return \"object\" === typeof a && null !== a && null != a.key ? $a77485e72fcbbe24$var$escape(\"\" + a.key) : b.toString(36);\n}\nfunction $a77485e72fcbbe24$var$R(a, b, e, d, c) {\n    var k = typeof a;\n    if (\"undefined\" === k || \"boolean\" === k) a = null;\n    var h = !1;\n    if (null === a) h = !0;\n    else switch(k){\n        case \"string\":\n        case \"number\":\n            h = !0;\n            break;\n        case \"object\":\n            switch(a.$$typeof){\n                case $a77485e72fcbbe24$var$l:\n                case $a77485e72fcbbe24$var$n:\n                    h = !0;\n            }\n    }\n    if (h) return h = a, c = c(h), a = \"\" === d ? \".\" + $a77485e72fcbbe24$var$Q(h, 0) : d, $a77485e72fcbbe24$var$I(c) ? (e = \"\", null != a && (e = a.replace($a77485e72fcbbe24$var$P, \"$&/\") + \"/\"), $a77485e72fcbbe24$var$R(c, b, e, \"\", function(a) {\n        return a;\n    })) : null != c && ($a77485e72fcbbe24$var$O(c) && (c = $a77485e72fcbbe24$var$N(c, e + (!c.key || h && h.key === c.key ? \"\" : (\"\" + c.key).replace($a77485e72fcbbe24$var$P, \"$&/\") + \"/\") + a)), b.push(c)), 1;\n    h = 0;\n    d = \"\" === d ? \".\" : d + \":\";\n    if ($a77485e72fcbbe24$var$I(a)) for(var g = 0; g < a.length; g++){\n        k = a[g];\n        var f = d + $a77485e72fcbbe24$var$Q(k, g);\n        h += $a77485e72fcbbe24$var$R(k, b, e, f, c);\n    }\n    else if (f = $a77485e72fcbbe24$var$A(a), \"function\" === typeof f) for(a = f.call(a), g = 0; !(k = a.next()).done;)k = k.value, f = d + $a77485e72fcbbe24$var$Q(k, g++), h += $a77485e72fcbbe24$var$R(k, b, e, f, c);\n    else if (\"object\" === k) throw b = String(a), Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === b ? \"object with keys {\" + Object.keys(a).join(\", \") + \"}\" : b) + \"). If you meant to render a collection of children, use an array instead.\");\n    return h;\n}\nfunction $a77485e72fcbbe24$var$S(a, b, e) {\n    if (null == a) return a;\n    var d = [], c = 0;\n    $a77485e72fcbbe24$var$R(a, d, \"\", \"\", function(a) {\n        return b.call(e, a, c++);\n    });\n    return d;\n}\nfunction $a77485e72fcbbe24$var$T(a) {\n    if (-1 === a._status) {\n        var b = a._result;\n        b = b();\n        b.then(function(b) {\n            if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;\n        }, function(b) {\n            if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;\n        });\n        -1 === a._status && (a._status = 0, a._result = b);\n    }\n    if (1 === a._status) return a._result.default;\n    throw a._result;\n}\nvar $a77485e72fcbbe24$var$U = {\n    current: null\n}, $a77485e72fcbbe24$var$V = {\n    transition: null\n}, $a77485e72fcbbe24$var$W = {\n    ReactCurrentDispatcher: $a77485e72fcbbe24$var$U,\n    ReactCurrentBatchConfig: $a77485e72fcbbe24$var$V,\n    ReactCurrentOwner: $a77485e72fcbbe24$var$K\n};\n$a77485e72fcbbe24$export$dca3b0875bd9a954 = {\n    map: $a77485e72fcbbe24$var$S,\n    forEach: function(a, b, e) {\n        $a77485e72fcbbe24$var$S(a, function() {\n            b.apply(this, arguments);\n        }, e);\n    },\n    count: function(a) {\n        var b = 0;\n        $a77485e72fcbbe24$var$S(a, function() {\n            b++;\n        });\n        return b;\n    },\n    toArray: function(a) {\n        return $a77485e72fcbbe24$var$S(a, function(a) {\n            return a;\n        }) || [];\n    },\n    only: function(a) {\n        if (!$a77485e72fcbbe24$var$O(a)) throw Error(\"React.Children.only expected to receive a single React element child.\");\n        return a;\n    }\n};\n$a77485e72fcbbe24$export$16fa2f45be04daa8 = $a77485e72fcbbe24$var$E;\n$a77485e72fcbbe24$export$ffb0004e005737fa = $a77485e72fcbbe24$var$p;\n$a77485e72fcbbe24$export$e2c29f18771995cb = $a77485e72fcbbe24$var$r;\n$a77485e72fcbbe24$export$221d75b3f55bb0bd = $a77485e72fcbbe24$var$G;\n$a77485e72fcbbe24$export$5f8d39834fd61797 = $a77485e72fcbbe24$var$q;\n$a77485e72fcbbe24$export$74bf444e3cd11ea5 = $a77485e72fcbbe24$var$w;\n$a77485e72fcbbe24$export$ae55be85d98224ed = $a77485e72fcbbe24$var$W;\n$a77485e72fcbbe24$export$e530037191fcd5d7 = function(a, b, e) {\n    if (null === a || void 0 === a) throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + a + \".\");\n    var d = $a77485e72fcbbe24$var$C({}, a.props), c = a.key, k = a.ref, h = a._owner;\n    if (null != b) {\n        void 0 !== b.ref && (k = b.ref, h = $a77485e72fcbbe24$var$K.current);\n        void 0 !== b.key && (c = \"\" + b.key);\n        if (a.type && a.type.defaultProps) var g = a.type.defaultProps;\n        for(f in b)$a77485e72fcbbe24$var$J.call(b, f) && !$a77485e72fcbbe24$var$L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);\n    }\n    var f = arguments.length - 2;\n    if (1 === f) d.children = e;\n    else if (1 < f) {\n        g = Array(f);\n        for(var m = 0; m < f; m++)g[m] = arguments[m + 2];\n        d.children = g;\n    }\n    return {\n        $$typeof: $a77485e72fcbbe24$var$l,\n        type: a.type,\n        key: c,\n        ref: k,\n        props: d,\n        _owner: h\n    };\n};\n$a77485e72fcbbe24$export$fd42f52fd3ae1109 = function(a) {\n    a = {\n        $$typeof: $a77485e72fcbbe24$var$u,\n        _currentValue: a,\n        _currentValue2: a,\n        _threadCount: 0,\n        Provider: null,\n        Consumer: null,\n        _defaultValue: null,\n        _globalName: null\n    };\n    a.Provider = {\n        $$typeof: $a77485e72fcbbe24$var$t,\n        _context: a\n    };\n    return a.Consumer = a;\n};\n$a77485e72fcbbe24$export$c8a8987d4410bf2d = $a77485e72fcbbe24$var$M;\n$a77485e72fcbbe24$export$d38cd72104c1f0e9 = function(a) {\n    var b = $a77485e72fcbbe24$var$M.bind(null, a);\n    b.type = a;\n    return b;\n};\n$a77485e72fcbbe24$export$7d1e3a5e95ceca43 = function() {\n    return {\n        current: null\n    };\n};\n$a77485e72fcbbe24$export$257a8862b851cb5b = function(a) {\n    return {\n        $$typeof: $a77485e72fcbbe24$var$v,\n        render: a\n    };\n};\n$a77485e72fcbbe24$export$a8257692ac88316c = $a77485e72fcbbe24$var$O;\n$a77485e72fcbbe24$export$488013bae63b21da = function(a) {\n    return {\n        $$typeof: $a77485e72fcbbe24$var$y,\n        _payload: {\n            _status: -1,\n            _result: a\n        },\n        _init: $a77485e72fcbbe24$var$T\n    };\n};\n$a77485e72fcbbe24$export$7c73462e0d25e514 = function(a, b) {\n    return {\n        $$typeof: $a77485e72fcbbe24$var$x,\n        type: a,\n        compare: void 0 === b ? null : b\n    };\n};\n$a77485e72fcbbe24$export$7568632d0d33d16d = function(a) {\n    var b = $a77485e72fcbbe24$var$V.transition;\n    $a77485e72fcbbe24$var$V.transition = {};\n    try {\n        a();\n    } finally{\n        $a77485e72fcbbe24$var$V.transition = b;\n    }\n};\n$a77485e72fcbbe24$export$88948ce120ea2619 = function() {\n    throw Error(\"act(...) is not supported in production builds of React.\");\n};\n$a77485e72fcbbe24$export$35808ee640e87ca7 = function(a, b) {\n    return $a77485e72fcbbe24$var$U.current.useCallback(a, b);\n};\n$a77485e72fcbbe24$export$fae74005e78b1a27 = function(a) {\n    return $a77485e72fcbbe24$var$U.current.useContext(a);\n};\n$a77485e72fcbbe24$export$dc8fbce3eb94dc1e = function() {};\n$a77485e72fcbbe24$export$6a7bc4e911dc01cf = function(a) {\n    return $a77485e72fcbbe24$var$U.current.useDeferredValue(a);\n};\n$a77485e72fcbbe24$export$6d9c69b0de29b591 = function(a, b) {\n    return $a77485e72fcbbe24$var$U.current.useEffect(a, b);\n};\n$a77485e72fcbbe24$export$f680877a34711e37 = function() {\n    return $a77485e72fcbbe24$var$U.current.useId();\n};\n$a77485e72fcbbe24$export$d5a552a76deda3c2 = function(a, b, e) {\n    return $a77485e72fcbbe24$var$U.current.useImperativeHandle(a, b, e);\n};\n$a77485e72fcbbe24$export$aaabe4eda9ed9969 = function(a, b) {\n    return $a77485e72fcbbe24$var$U.current.useInsertionEffect(a, b);\n};\n$a77485e72fcbbe24$export$e5c5a5f917a5871c = function(a, b) {\n    return $a77485e72fcbbe24$var$U.current.useLayoutEffect(a, b);\n};\n$a77485e72fcbbe24$export$1538c33de8887b59 = function(a, b) {\n    return $a77485e72fcbbe24$var$U.current.useMemo(a, b);\n};\n$a77485e72fcbbe24$export$13e3392192263954 = function(a, b, e) {\n    return $a77485e72fcbbe24$var$U.current.useReducer(a, b, e);\n};\n$a77485e72fcbbe24$export$b8f5890fc79d6aca = function(a) {\n    return $a77485e72fcbbe24$var$U.current.useRef(a);\n};\n$a77485e72fcbbe24$export$60241385465d0a34 = function(a) {\n    return $a77485e72fcbbe24$var$U.current.useState(a);\n};\n$a77485e72fcbbe24$export$306c0aa65ff9ec16 = function(a, b, e) {\n    return $a77485e72fcbbe24$var$U.current.useSyncExternalStore(a, b, e);\n};\n$a77485e72fcbbe24$export$7b286972b8d8ccbf = function() {\n    return $a77485e72fcbbe24$var$U.current.useTransition();\n};\n$a77485e72fcbbe24$export$83d89fbfd8236492 = \"18.2.0\";\n\n});\n\nvar $51f7dce148526514$exports = {};\nlet $ca07057eef1ab6c2$export$e538f94cc8cf4db8 = [];\nlet $ca07057eef1ab6c2$export$83d89fbfd8236492 = \"\";\nfunction $ca07057eef1ab6c2$export$c208e1278d7beb2(m, v) {\n    $ca07057eef1ab6c2$export$e538f94cc8cf4db8 = m;\n    $ca07057eef1ab6c2$export$83d89fbfd8236492 = v;\n}\n\n\nconst $51f7dce148526514$var$manifest = [\n    \"index.html\",\n    \"favicon.47681ad3.ico\",\n    \"site.webmanifest\",\n    \"icon-l.7082b16d.png\",\n    \"index.d1655808.js\",\n    \"index.6134c3ca.css\",\n    \"index.476326c1.js\"\n];\nconst $51f7dce148526514$var$version = \"dfe300a7\";\n(0, $ca07057eef1ab6c2$export$c208e1278d7beb2)($51f7dce148526514$var$manifest, $51f7dce148526514$var$version);\n\nvar $fb1bb2d850b60f11$exports = {};\n/// <reference lib=\"WebWorker\" />\n// export empty type because of tsc --isolatedModules flag\n\nvar $a189fc184070e3b9$exports = {};\n/*!\n    localForage -- Offline Storage, Improved\n    Version 1.10.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/ (function(f) {\n    var g;\n    $a189fc184070e3b9$exports = f();\n})(function() {\n    var define, module1, exports;\n    return (function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = undefined;\n                    if (!u && a) return a(o, !0);\n                    if (i) return i(o, !0);\n                    var f = new Error(\"Cannot find module '\" + o + \"'\");\n                    throw f.code = \"MODULE_NOT_FOUND\", f;\n                }\n                var l = n[o] = {\n                    exports: {}\n                };\n                t[o][0].call(l.exports, function(e) {\n                    var n = t[o][1][e];\n                    return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }\n            return n[o].exports;\n        }\n        var i = undefined;\n        for(var o = 0; o < r.length; o++)s(r[o]);\n        return s;\n    })({\n        1: [\n            function(_dereq_, module1, exports) {\n                (function(global1) {\n                    \"use strict\";\n                    var Mutation = global1.MutationObserver || global1.WebKitMutationObserver;\n                    var scheduleDrain;\n                    if (Mutation) {\n                        var called = 0;\n                        var observer = new Mutation(nextTick);\n                        var element = global1.document.createTextNode(\"\");\n                        observer.observe(element, {\n                            characterData: true\n                        });\n                        scheduleDrain = function() {\n                            element.data = called = ++called % 2;\n                        };\n                    } else if (!global1.setImmediate && typeof global1.MessageChannel !== \"undefined\") {\n                        var channel = new global1.MessageChannel();\n                        channel.port1.onmessage = nextTick;\n                        scheduleDrain = function() {\n                            channel.port2.postMessage(0);\n                        };\n                    } else if (\"document\" in global1 && \"onreadystatechange\" in global1.document.createElement(\"script\")) scheduleDrain = function() {\n                        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n                        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n                        var scriptEl = global1.document.createElement(\"script\");\n                        scriptEl.onreadystatechange = function() {\n                            nextTick();\n                            scriptEl.onreadystatechange = null;\n                            scriptEl.parentNode.removeChild(scriptEl);\n                            scriptEl = null;\n                        };\n                        global1.document.documentElement.appendChild(scriptEl);\n                    };\n                    else scheduleDrain = function() {\n                        setTimeout(nextTick, 0);\n                    };\n                    var draining;\n                    var queue = [];\n                    //named nextTick for less confusing stack traces\n                    function nextTick() {\n                        draining = true;\n                        var i, oldQueue;\n                        var len = queue.length;\n                        while(len){\n                            oldQueue = queue;\n                            queue = [];\n                            i = -1;\n                            while(++i < len)oldQueue[i]();\n                            len = queue.length;\n                        }\n                        draining = false;\n                    }\n                    module1.exports = immediate;\n                    function immediate(task) {\n                        if (queue.push(task) === 1 && !draining) scheduleDrain();\n                    }\n                }).call(this, typeof $parcel$global !== \"undefined\" ? $parcel$global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n            },\n            {}\n        ],\n        2: [\n            function(_dereq_, module1, exports) {\n                \"use strict\";\n                var immediate = _dereq_(1);\n                /* istanbul ignore next */ function INTERNAL() {}\n                var handlers = {};\n                var REJECTED = [\n                    \"REJECTED\"\n                ];\n                var FULFILLED = [\n                    \"FULFILLED\"\n                ];\n                var PENDING = [\n                    \"PENDING\"\n                ];\n                module1.exports = Promise1;\n                function Promise1(resolver) {\n                    if (typeof resolver !== \"function\") throw new TypeError(\"resolver must be a function\");\n                    this.state = PENDING;\n                    this.queue = [];\n                    this.outcome = void 0;\n                    if (resolver !== INTERNAL) safelyResolveThenable(this, resolver);\n                }\n                Promise1.prototype[\"catch\"] = function(onRejected) {\n                    return this.then(null, onRejected);\n                };\n                Promise1.prototype.then = function(onFulfilled, onRejected) {\n                    if (typeof onFulfilled !== \"function\" && this.state === FULFILLED || typeof onRejected !== \"function\" && this.state === REJECTED) return this;\n                    var promise = new this.constructor(INTERNAL);\n                    if (this.state !== PENDING) {\n                        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n                        unwrap(promise, resolver, this.outcome);\n                    } else this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n                    return promise;\n                };\n                function QueueItem(promise, onFulfilled, onRejected) {\n                    this.promise = promise;\n                    if (typeof onFulfilled === \"function\") {\n                        this.onFulfilled = onFulfilled;\n                        this.callFulfilled = this.otherCallFulfilled;\n                    }\n                    if (typeof onRejected === \"function\") {\n                        this.onRejected = onRejected;\n                        this.callRejected = this.otherCallRejected;\n                    }\n                }\n                QueueItem.prototype.callFulfilled = function(value) {\n                    handlers.resolve(this.promise, value);\n                };\n                QueueItem.prototype.otherCallFulfilled = function(value) {\n                    unwrap(this.promise, this.onFulfilled, value);\n                };\n                QueueItem.prototype.callRejected = function(value) {\n                    handlers.reject(this.promise, value);\n                };\n                QueueItem.prototype.otherCallRejected = function(value) {\n                    unwrap(this.promise, this.onRejected, value);\n                };\n                function unwrap(promise, func, value) {\n                    immediate(function() {\n                        var returnValue;\n                        try {\n                            returnValue = func(value);\n                        } catch (e) {\n                            return handlers.reject(promise, e);\n                        }\n                        if (returnValue === promise) handlers.reject(promise, new TypeError(\"Cannot resolve promise with itself\"));\n                        else handlers.resolve(promise, returnValue);\n                    });\n                }\n                handlers.resolve = function(self1, value) {\n                    var result = tryCatch(getThen, value);\n                    if (result.status === \"error\") return handlers.reject(self1, result.value);\n                    var thenable = result.value;\n                    if (thenable) safelyResolveThenable(self1, thenable);\n                    else {\n                        self1.state = FULFILLED;\n                        self1.outcome = value;\n                        var i = -1;\n                        var len = self1.queue.length;\n                        while(++i < len)self1.queue[i].callFulfilled(value);\n                    }\n                    return self1;\n                };\n                handlers.reject = function(self1, error) {\n                    self1.state = REJECTED;\n                    self1.outcome = error;\n                    var i = -1;\n                    var len = self1.queue.length;\n                    while(++i < len)self1.queue[i].callRejected(error);\n                    return self1;\n                };\n                function getThen(obj) {\n                    // Make sure we only access the accessor once as required by the spec\n                    var then = obj && obj.then;\n                    if (obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof then === \"function\") return function appyThen() {\n                        then.apply(obj, arguments);\n                    };\n                }\n                function safelyResolveThenable(self1, thenable) {\n                    // Either fulfill, reject or reject with error\n                    var called = false;\n                    function onError(value) {\n                        if (called) return;\n                        called = true;\n                        handlers.reject(self1, value);\n                    }\n                    function onSuccess(value) {\n                        if (called) return;\n                        called = true;\n                        handlers.resolve(self1, value);\n                    }\n                    function tryToUnwrap() {\n                        thenable(onSuccess, onError);\n                    }\n                    var result = tryCatch(tryToUnwrap);\n                    if (result.status === \"error\") onError(result.value);\n                }\n                function tryCatch(func, value) {\n                    var out = {};\n                    try {\n                        out.value = func(value);\n                        out.status = \"success\";\n                    } catch (e) {\n                        out.status = \"error\";\n                        out.value = e;\n                    }\n                    return out;\n                }\n                Promise1.resolve = resolve;\n                function resolve(value) {\n                    if (value instanceof this) return value;\n                    return handlers.resolve(new this(INTERNAL), value);\n                }\n                Promise1.reject = reject;\n                function reject(reason) {\n                    var promise = new this(INTERNAL);\n                    return handlers.reject(promise, reason);\n                }\n                Promise1.all = all;\n                function all(iterable) {\n                    var self1 = this;\n                    if (Object.prototype.toString.call(iterable) !== \"[object Array]\") return this.reject(new TypeError(\"must be an array\"));\n                    var len = iterable.length;\n                    var called = false;\n                    if (!len) return this.resolve([]);\n                    var values = new Array(len);\n                    var resolved = 0;\n                    var i = -1;\n                    var promise = new this(INTERNAL);\n                    while(++i < len)allResolver(iterable[i], i);\n                    return promise;\n                    function allResolver(value, i) {\n                        self1.resolve(value).then(resolveFromAll, function(error) {\n                            if (!called) {\n                                called = true;\n                                handlers.reject(promise, error);\n                            }\n                        });\n                        function resolveFromAll(outValue) {\n                            values[i] = outValue;\n                            if (++resolved === len && !called) {\n                                called = true;\n                                handlers.resolve(promise, values);\n                            }\n                        }\n                    }\n                }\n                Promise1.race = race;\n                function race(iterable) {\n                    var self1 = this;\n                    if (Object.prototype.toString.call(iterable) !== \"[object Array]\") return this.reject(new TypeError(\"must be an array\"));\n                    var len = iterable.length;\n                    var called = false;\n                    if (!len) return this.resolve([]);\n                    var i = -1;\n                    var promise = new this(INTERNAL);\n                    while(++i < len)resolver(iterable[i]);\n                    return promise;\n                    function resolver(value) {\n                        self1.resolve(value).then(function(response) {\n                            if (!called) {\n                                called = true;\n                                handlers.resolve(promise, response);\n                            }\n                        }, function(error) {\n                            if (!called) {\n                                called = true;\n                                handlers.reject(promise, error);\n                            }\n                        });\n                    }\n                }\n            },\n            {\n                \"1\": 1\n            }\n        ],\n        3: [\n            function(_dereq_, module1, exports) {\n                (function(global1) {\n                    \"use strict\";\n                    if (typeof global1.Promise !== \"function\") global1.Promise = _dereq_(2);\n                }).call(this, typeof $parcel$global !== \"undefined\" ? $parcel$global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n            },\n            {\n                \"2\": 2\n            }\n        ],\n        4: [\n            function(_dereq_, module1, exports) {\n                \"use strict\";\n                var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                };\n                function _classCallCheck(instance, Constructor) {\n                    if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n                }\n                function getIDB() {\n                    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */ try {\n                        if (typeof indexedDB !== \"undefined\") return indexedDB;\n                        if (typeof webkitIndexedDB !== \"undefined\") return webkitIndexedDB;\n                        if (typeof mozIndexedDB !== \"undefined\") return mozIndexedDB;\n                        if (typeof OIndexedDB !== \"undefined\") return OIndexedDB;\n                        if (typeof msIndexedDB !== \"undefined\") return msIndexedDB;\n                    } catch (e) {\n                        return;\n                    }\n                }\n                var idb = getIDB();\n                function isIndexedDBValid() {\n                    try {\n                        // Initialize IndexedDB; fall back to vendor-prefixed versions\n                        // if needed.\n                        if (!idb || !idb.open) return false;\n                        // We mimic PouchDB here;\n                        //\n                        // We test for openDatabase because IE Mobile identifies itself\n                        // as Safari. Oh the lulz...\n                        var isSafari = typeof openDatabase !== \"undefined\" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n                        var hasFetch = typeof fetch === \"function\" && fetch.toString().indexOf(\"[native code\") !== -1;\n                        // Safari <10.1 does not meet our requirements for IDB support\n                        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n                        // Safari 10.1 shipped with fetch, we can use that to detect it.\n                        // Note: this creates issues with `window.fetch` polyfills and\n                        // overrides; see:\n                        // https://github.com/localForage/localForage/issues/856\n                        return (!isSafari || hasFetch) && typeof indexedDB !== \"undefined\" && // some outdated implementations of IDB that appear on Samsung\n                        // and HTC Android devices <4.4 are missing IDBKeyRange\n                        // See: https://github.com/mozilla/localForage/issues/128\n                        // See: https://github.com/mozilla/localForage/issues/272\n                        typeof IDBKeyRange !== \"undefined\";\n                    } catch (e) {\n                        return false;\n                    }\n                }\n                // Abstracts constructing a Blob object, so it also works in older\n                // browsers that don't support the native Blob constructor. (i.e.\n                // old QtWebKit versions, at least).\n                // Abstracts constructing a Blob object, so it also works in older\n                // browsers that don't support the native Blob constructor. (i.e.\n                // old QtWebKit versions, at least).\n                function createBlob(parts, properties) {\n                    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */ parts = parts || [];\n                    properties = properties || {};\n                    try {\n                        return new Blob(parts, properties);\n                    } catch (e) {\n                        if (e.name !== \"TypeError\") throw e;\n                        var Builder = typeof BlobBuilder !== \"undefined\" ? BlobBuilder : typeof MSBlobBuilder !== \"undefined\" ? MSBlobBuilder : typeof MozBlobBuilder !== \"undefined\" ? MozBlobBuilder : WebKitBlobBuilder;\n                        var builder = new Builder();\n                        for(var i = 0; i < parts.length; i += 1)builder.append(parts[i]);\n                        return builder.getBlob(properties.type);\n                    }\n                }\n                // This is CommonJS because lie is an external dependency, so Rollup\n                // can just ignore it.\n                if (typeof Promise === \"undefined\") // In the \"nopromises\" build this will just throw if you don't have\n                // a global promise object, but it would throw anyway later.\n                _dereq_(3);\n                var Promise$1 = Promise;\n                function executeCallback(promise, callback) {\n                    if (callback) promise.then(function(result) {\n                        callback(null, result);\n                    }, function(error) {\n                        callback(error);\n                    });\n                }\n                function executeTwoCallbacks(promise, callback, errorCallback) {\n                    if (typeof callback === \"function\") promise.then(callback);\n                    if (typeof errorCallback === \"function\") promise[\"catch\"](errorCallback);\n                }\n                function normalizeKey(key) {\n                    // Cast the key to a string, as that's all we can set as a key.\n                    if (typeof key !== \"string\") {\n                        console.warn(key + \" used as a key, but it is not a string.\");\n                        key = String(key);\n                    }\n                    return key;\n                }\n                function getCallback() {\n                    if (arguments.length && typeof arguments[arguments.length - 1] === \"function\") return arguments[arguments.length - 1];\n                }\n                // Some code originally from async_storage.js in\n                // [Gaia](https://github.com/mozilla-b2g/gaia).\n                var DETECT_BLOB_SUPPORT_STORE = \"local-forage-detect-blob-support\";\n                var supportsBlobs = void 0;\n                var dbContexts = {};\n                var toString = Object.prototype.toString;\n                // Transaction Modes\n                var READ_ONLY = \"readonly\";\n                var READ_WRITE = \"readwrite\";\n                // Transform a binary string to an array buffer, because otherwise\n                // weird stuff happens when you try to work with the binary string directly.\n                // It is known.\n                // From http://stackoverflow.com/questions/14967647/ (continues on next line)\n                // encode-decode-image-with-base64-breaks-image (2013-04-21)\n                function _binStringToArrayBuffer(bin) {\n                    var length = bin.length;\n                    var buf = new ArrayBuffer(length);\n                    var arr = new Uint8Array(buf);\n                    for(var i = 0; i < length; i++)arr[i] = bin.charCodeAt(i);\n                    return buf;\n                }\n                //\n                // Blobs are not supported in all versions of IndexedDB, notably\n                // Chrome <37 and Android <5. In those versions, storing a blob will throw.\n                //\n                // Various other blob bugs exist in Chrome v37-42 (inclusive).\n                // Detecting them is expensive and confusing to users, and Chrome 37-42\n                // is at very low usage worldwide, so we do a hacky userAgent check instead.\n                //\n                // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n                // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n                // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n                //\n                // Code borrowed from PouchDB. See:\n                // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n                //\n                function _checkBlobSupportWithoutCaching(idb) {\n                    return new Promise$1(function(resolve) {\n                        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n                        var blob = createBlob([\n                            \"\"\n                        ]);\n                        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, \"key\");\n                        txn.onabort = function(e) {\n                            // If the transaction aborts now its due to not being able to\n                            // write to the database, likely due to the disk being full\n                            e.preventDefault();\n                            e.stopPropagation();\n                            resolve(false);\n                        };\n                        txn.oncomplete = function() {\n                            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n                            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n                            // MS Edge pretends to be Chrome 42:\n                            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n                            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n                        };\n                    })[\"catch\"](function() {\n                        return false; // error, so assume unsupported\n                    });\n                }\n                function _checkBlobSupport(idb) {\n                    if (typeof supportsBlobs === \"boolean\") return Promise$1.resolve(supportsBlobs);\n                    return _checkBlobSupportWithoutCaching(idb).then(function(value) {\n                        supportsBlobs = value;\n                        return supportsBlobs;\n                    });\n                }\n                function _deferReadiness(dbInfo) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Create a deferred object representing the current database operation.\n                    var deferredOperation = {};\n                    deferredOperation.promise = new Promise$1(function(resolve, reject) {\n                        deferredOperation.resolve = resolve;\n                        deferredOperation.reject = reject;\n                    });\n                    // Enqueue the deferred operation.\n                    dbContext.deferredOperations.push(deferredOperation);\n                    // Chain its promise to the database readiness.\n                    if (!dbContext.dbReady) dbContext.dbReady = deferredOperation.promise;\n                    else dbContext.dbReady = dbContext.dbReady.then(function() {\n                        return deferredOperation.promise;\n                    });\n                }\n                function _advanceReadiness(dbInfo) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Dequeue a deferred operation.\n                    var deferredOperation = dbContext.deferredOperations.pop();\n                    // Resolve its promise (which is part of the database readiness\n                    // chain of promises).\n                    if (deferredOperation) {\n                        deferredOperation.resolve();\n                        return deferredOperation.promise;\n                    }\n                }\n                function _rejectReadiness(dbInfo, err) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Dequeue a deferred operation.\n                    var deferredOperation = dbContext.deferredOperations.pop();\n                    // Reject its promise (which is part of the database readiness\n                    // chain of promises).\n                    if (deferredOperation) {\n                        deferredOperation.reject(err);\n                        return deferredOperation.promise;\n                    }\n                }\n                function _getConnection(dbInfo, upgradeNeeded) {\n                    return new Promise$1(function(resolve, reject) {\n                        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n                        if (dbInfo.db) {\n                            if (upgradeNeeded) {\n                                _deferReadiness(dbInfo);\n                                dbInfo.db.close();\n                            } else return resolve(dbInfo.db);\n                        }\n                        var dbArgs = [\n                            dbInfo.name\n                        ];\n                        if (upgradeNeeded) dbArgs.push(dbInfo.version);\n                        var openreq = idb.open.apply(idb, dbArgs);\n                        if (upgradeNeeded) openreq.onupgradeneeded = function(e) {\n                            var db = openreq.result;\n                            try {\n                                db.createObjectStore(dbInfo.storeName);\n                                if (e.oldVersion <= 1) // Added when support for blob shims was added\n                                db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                            } catch (ex) {\n                                if (ex.name === \"ConstraintError\") console.warn('The database \"' + dbInfo.name + '\"' + \" has been upgraded from version \" + e.oldVersion + \" to version \" + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                                else throw ex;\n                            }\n                        };\n                        openreq.onerror = function(e) {\n                            e.preventDefault();\n                            reject(openreq.error);\n                        };\n                        openreq.onsuccess = function() {\n                            var db = openreq.result;\n                            db.onversionchange = function(e) {\n                                // Triggered when the database is modified (e.g. adding an objectStore) or\n                                // deleted (even when initiated by other sessions in different tabs).\n                                // Closing the connection here prevents those operations from being blocked.\n                                // If the database is accessed again later by this instance, the connection\n                                // will be reopened or the database recreated as needed.\n                                e.target.close();\n                            };\n                            resolve(db);\n                            _advanceReadiness(dbInfo);\n                        };\n                    });\n                }\n                function _getOriginalConnection(dbInfo) {\n                    return _getConnection(dbInfo, false);\n                }\n                function _getUpgradedConnection(dbInfo) {\n                    return _getConnection(dbInfo, true);\n                }\n                function _isUpgradeNeeded(dbInfo, defaultVersion) {\n                    if (!dbInfo.db) return true;\n                    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n                    var isDowngrade = dbInfo.version < dbInfo.db.version;\n                    var isUpgrade = dbInfo.version > dbInfo.db.version;\n                    if (isDowngrade) {\n                        // If the version is not the default one\n                        // then warn for impossible downgrade.\n                        if (dbInfo.version !== defaultVersion) console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + \" to version \" + dbInfo.version + \".\");\n                        // Align the versions to prevent errors.\n                        dbInfo.version = dbInfo.db.version;\n                    }\n                    if (isUpgrade || isNewStore) {\n                        // If the store is new then increment the version (if needed).\n                        // This will trigger an \"upgradeneeded\" event which is required\n                        // for creating a store.\n                        if (isNewStore) {\n                            var incVersion = dbInfo.db.version + 1;\n                            if (incVersion > dbInfo.version) dbInfo.version = incVersion;\n                        }\n                        return true;\n                    }\n                    return false;\n                }\n                // encode a blob for indexeddb engines that don't support blobs\n                function _encodeBlob(blob) {\n                    return new Promise$1(function(resolve, reject) {\n                        var reader = new FileReader();\n                        reader.onerror = reject;\n                        reader.onloadend = function(e) {\n                            var base64 = btoa(e.target.result || \"\");\n                            resolve({\n                                __local_forage_encoded_blob: true,\n                                data: base64,\n                                type: blob.type\n                            });\n                        };\n                        reader.readAsBinaryString(blob);\n                    });\n                }\n                // decode an encoded blob\n                function _decodeBlob(encodedBlob) {\n                    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n                    return createBlob([\n                        arrayBuff\n                    ], {\n                        type: encodedBlob.type\n                    });\n                }\n                // is this one of our fancy encoded blobs?\n                function _isEncodedBlob(value) {\n                    return value && value.__local_forage_encoded_blob;\n                }\n                // Specialize the default `ready()` function by making it dependent\n                // on the current database operations. Thus, the driver will be actually\n                // ready when it's been initialized (default) *and* there are no pending\n                // operations on the database (initiated by some other instances).\n                function _fullyReady(callback) {\n                    var self1 = this;\n                    var promise = self1._initReady().then(function() {\n                        var dbContext = dbContexts[self1._dbInfo.name];\n                        if (dbContext && dbContext.dbReady) return dbContext.dbReady;\n                    });\n                    executeTwoCallbacks(promise, callback, callback);\n                    return promise;\n                }\n                // Try to establish a new db connection to replace the\n                // current one which is broken (i.e. experiencing\n                // InvalidStateError while creating a transaction).\n                function _tryReconnect(dbInfo) {\n                    _deferReadiness(dbInfo);\n                    var dbContext = dbContexts[dbInfo.name];\n                    var forages = dbContext.forages;\n                    for(var i = 0; i < forages.length; i++){\n                        var forage = forages[i];\n                        if (forage._dbInfo.db) {\n                            forage._dbInfo.db.close();\n                            forage._dbInfo.db = null;\n                        }\n                    }\n                    dbInfo.db = null;\n                    return _getOriginalConnection(dbInfo).then(function(db) {\n                        dbInfo.db = db;\n                        if (_isUpgradeNeeded(dbInfo)) // Reopen the database for upgrading.\n                        return _getUpgradedConnection(dbInfo);\n                        return db;\n                    }).then(function(db) {\n                        // store the latest db reference\n                        // in case the db was upgraded\n                        dbInfo.db = dbContext.db = db;\n                        for(var i = 0; i < forages.length; i++)forages[i]._dbInfo.db = db;\n                    })[\"catch\"](function(err) {\n                        _rejectReadiness(dbInfo, err);\n                        throw err;\n                    });\n                }\n                // FF doesn't like Promises (micro-tasks) and IDDB store operations,\n                // so we have to do it with callbacks\n                function createTransaction(dbInfo, mode, callback, retries) {\n                    if (retries === undefined) retries = 1;\n                    try {\n                        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n                        callback(null, tx);\n                    } catch (err) {\n                        if (retries > 0 && (!dbInfo.db || err.name === \"InvalidStateError\" || err.name === \"NotFoundError\")) return Promise$1.resolve().then(function() {\n                            if (!dbInfo.db || err.name === \"NotFoundError\" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                                // increase the db version, to create the new ObjectStore\n                                if (dbInfo.db) dbInfo.version = dbInfo.db.version + 1;\n                                // Reopen the database for upgrading.\n                                return _getUpgradedConnection(dbInfo);\n                            }\n                        }).then(function() {\n                            return _tryReconnect(dbInfo).then(function() {\n                                createTransaction(dbInfo, mode, callback, retries - 1);\n                            });\n                        })[\"catch\"](callback);\n                        callback(err);\n                    }\n                }\n                function createDbContext() {\n                    return {\n                        // Running localForages sharing a database.\n                        forages: [],\n                        // Shared database.\n                        db: null,\n                        // Database readiness (promise).\n                        dbReady: null,\n                        // Deferred operations on the database.\n                        deferredOperations: []\n                    };\n                }\n                // Open the IndexedDB database (automatically creates one if one didn't\n                // previously exist), using any options set in the config.\n                function _initStorage(options) {\n                    var self1 = this;\n                    var dbInfo = {\n                        db: null\n                    };\n                    if (options) for(var i in options)dbInfo[i] = options[i];\n                    // Get the current context of the database;\n                    var dbContext = dbContexts[dbInfo.name];\n                    // ...or create a new context.\n                    if (!dbContext) {\n                        dbContext = createDbContext();\n                        // Register the new context in the global container.\n                        dbContexts[dbInfo.name] = dbContext;\n                    }\n                    // Register itself as a running localForage in the current context.\n                    dbContext.forages.push(self1);\n                    // Replace the default `ready()` function with the specialized one.\n                    if (!self1._initReady) {\n                        self1._initReady = self1.ready;\n                        self1.ready = _fullyReady;\n                    }\n                    // Create an array of initialization states of the related localForages.\n                    var initPromises = [];\n                    function ignoreErrors() {\n                        // Don't handle errors here,\n                        // just makes sure related localForages aren't pending.\n                        return Promise$1.resolve();\n                    }\n                    for(var j = 0; j < dbContext.forages.length; j++){\n                        var forage = dbContext.forages[j];\n                        if (forage !== self1) // Don't wait for itself...\n                        initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n                    }\n                    // Take a snapshot of the related localForages.\n                    var forages = dbContext.forages.slice(0);\n                    // Initialize the connection process only when\n                    // all the related localForages aren't pending.\n                    return Promise$1.all(initPromises).then(function() {\n                        dbInfo.db = dbContext.db;\n                        // Get the connection or open a new one without upgrade.\n                        return _getOriginalConnection(dbInfo);\n                    }).then(function(db) {\n                        dbInfo.db = db;\n                        if (_isUpgradeNeeded(dbInfo, self1._defaultConfig.version)) // Reopen the database for upgrading.\n                        return _getUpgradedConnection(dbInfo);\n                        return db;\n                    }).then(function(db) {\n                        dbInfo.db = dbContext.db = db;\n                        self1._dbInfo = dbInfo;\n                        // Share the final connection amongst related localForages.\n                        for(var k = 0; k < forages.length; k++){\n                            var forage = forages[k];\n                            if (forage !== self1) {\n                                // Self is already up-to-date.\n                                forage._dbInfo.db = dbInfo.db;\n                                forage._dbInfo.version = dbInfo.version;\n                            }\n                        }\n                    });\n                }\n                function getItem(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.get(key);\n                                    req.onsuccess = function() {\n                                        var value = req.result;\n                                        if (value === undefined) value = null;\n                                        if (_isEncodedBlob(value)) value = _decodeBlob(value);\n                                        resolve(value);\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Iterate over all items stored in database.\n                function iterate(iterator, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.openCursor();\n                                    var iterationNumber = 1;\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (cursor) {\n                                            var value = cursor.value;\n                                            if (_isEncodedBlob(value)) value = _decodeBlob(value);\n                                            var result = iterator(value, cursor.key, iterationNumber++);\n                                            // when the iterator callback returns any\n                                            // (non-`undefined`) value, then we stop\n                                            // the iteration immediately\n                                            if (result !== void 0) resolve(result);\n                                            else cursor[\"continue\"]();\n                                        } else resolve();\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function setItem(key, value, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        var dbInfo;\n                        self1.ready().then(function() {\n                            dbInfo = self1._dbInfo;\n                            if (toString.call(value) === \"[object Blob]\") return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {\n                                if (blobSupport) return value;\n                                return _encodeBlob(value);\n                            });\n                            return value;\n                        }).then(function(value) {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    // The reason we don't _save_ null is because IE 10 does\n                                    // not support saving the `null` type in IndexedDB. How\n                                    // ironic, given the bug below!\n                                    // See: https://github.com/mozilla/localForage/issues/161\n                                    if (value === null) value = undefined;\n                                    var req = store.put(value, key);\n                                    transaction.oncomplete = function() {\n                                        // Cast to undefined so the value passed to\n                                        // callback/promise is the same as what one would get out\n                                        // of `getItem()` later. This leads to some weirdness\n                                        // (setItem('foo', undefined) will return `null`), but\n                                        // it's not my fault localStorage is our baseline and that\n                                        // it's weird.\n                                        if (value === undefined) value = null;\n                                        resolve(value);\n                                    };\n                                    transaction.onabort = transaction.onerror = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function removeItem(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    // We use a Grunt task to make this safe for IE and some\n                                    // versions of Android (including those used by Cordova).\n                                    // Normally IE won't like `.delete()` and will insist on\n                                    // using `['delete']()`, but we have a build step that\n                                    // fixes this for us now.\n                                    var req = store[\"delete\"](key);\n                                    transaction.oncomplete = function() {\n                                        resolve();\n                                    };\n                                    transaction.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                    // The request will be also be aborted if we've exceeded our storage\n                                    // space.\n                                    transaction.onabort = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function clear(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.clear();\n                                    transaction.oncomplete = function() {\n                                        resolve();\n                                    };\n                                    transaction.onabort = transaction.onerror = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function length(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.count();\n                                    req.onsuccess = function() {\n                                        resolve(req.result);\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function key(n, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        if (n < 0) {\n                            resolve(null);\n                            return;\n                        }\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var advanced = false;\n                                    var req = store.openKeyCursor();\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (!cursor) {\n                                            // this means there weren't enough keys\n                                            resolve(null);\n                                            return;\n                                        }\n                                        if (n === 0) // We have the first key, return it if that's what they\n                                        // wanted.\n                                        resolve(cursor.key);\n                                        else if (!advanced) {\n                                            // Otherwise, ask the cursor to skip ahead n\n                                            // records.\n                                            advanced = true;\n                                            cursor.advance(n);\n                                        } else // When we get here, we've got the nth key.\n                                        resolve(cursor.key);\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.openKeyCursor();\n                                    var keys = [];\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (!cursor) {\n                                            resolve(keys);\n                                            return;\n                                        }\n                                        keys.push(cursor.key);\n                                        cursor[\"continue\"]();\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function dropInstance(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    var currentConfig = this.config();\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) promise = Promise$1.reject(\"Invalid arguments\");\n                    else {\n                        var isCurrentDb = options.name === currentConfig.name && self1._dbInfo.db;\n                        var dbPromise = isCurrentDb ? Promise$1.resolve(self1._dbInfo.db) : _getOriginalConnection(options).then(function(db) {\n                            var dbContext = dbContexts[options.name];\n                            var forages = dbContext.forages;\n                            dbContext.db = db;\n                            for(var i = 0; i < forages.length; i++)forages[i]._dbInfo.db = db;\n                            return db;\n                        });\n                        if (!options.storeName) promise = dbPromise.then(function(db) {\n                            _deferReadiness(options);\n                            var dbContext = dbContexts[options.name];\n                            var forages = dbContext.forages;\n                            db.close();\n                            for(var i = 0; i < forages.length; i++){\n                                var forage = forages[i];\n                                forage._dbInfo.db = null;\n                            }\n                            var dropDBPromise = new Promise$1(function(resolve, reject) {\n                                var req = idb.deleteDatabase(options.name);\n                                req.onerror = function() {\n                                    var db = req.result;\n                                    if (db) db.close();\n                                    reject(req.error);\n                                };\n                                req.onblocked = function() {\n                                    // Closing all open connections in onversionchange handler should prevent this situation, but if\n                                    // we do get here, it just means the request remains pending - eventually it will succeed or error\n                                    console.warn('dropInstance blocked for database \"' + options.name + '\" until all open connections are closed');\n                                };\n                                req.onsuccess = function() {\n                                    var db = req.result;\n                                    if (db) db.close();\n                                    resolve(db);\n                                };\n                            });\n                            return dropDBPromise.then(function(db) {\n                                dbContext.db = db;\n                                for(var i = 0; i < forages.length; i++){\n                                    var _forage = forages[i];\n                                    _advanceReadiness(_forage._dbInfo);\n                                }\n                            })[\"catch\"](function(err) {\n                                (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function() {});\n                                throw err;\n                            });\n                        });\n                        else promise = dbPromise.then(function(db) {\n                            if (!db.objectStoreNames.contains(options.storeName)) return;\n                            var newVersion = db.version + 1;\n                            _deferReadiness(options);\n                            var dbContext = dbContexts[options.name];\n                            var forages = dbContext.forages;\n                            db.close();\n                            for(var i = 0; i < forages.length; i++){\n                                var forage = forages[i];\n                                forage._dbInfo.db = null;\n                                forage._dbInfo.version = newVersion;\n                            }\n                            var dropObjectPromise = new Promise$1(function(resolve, reject) {\n                                var req = idb.open(options.name, newVersion);\n                                req.onerror = function(err) {\n                                    var db = req.result;\n                                    db.close();\n                                    reject(err);\n                                };\n                                req.onupgradeneeded = function() {\n                                    var db = req.result;\n                                    db.deleteObjectStore(options.storeName);\n                                };\n                                req.onsuccess = function() {\n                                    var db = req.result;\n                                    db.close();\n                                    resolve(db);\n                                };\n                            });\n                            return dropObjectPromise.then(function(db) {\n                                dbContext.db = db;\n                                for(var j = 0; j < forages.length; j++){\n                                    var _forage2 = forages[j];\n                                    _forage2._dbInfo.db = db;\n                                    _advanceReadiness(_forage2._dbInfo);\n                                }\n                            })[\"catch\"](function(err) {\n                                (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function() {});\n                                throw err;\n                            });\n                        });\n                    }\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var asyncStorage = {\n                    _driver: \"asyncStorage\",\n                    _initStorage: _initStorage,\n                    _support: isIndexedDBValid(),\n                    iterate: iterate,\n                    getItem: getItem,\n                    setItem: setItem,\n                    removeItem: removeItem,\n                    clear: clear,\n                    length: length,\n                    key: key,\n                    keys: keys,\n                    dropInstance: dropInstance\n                };\n                function isWebSQLValid() {\n                    return typeof openDatabase === \"function\";\n                }\n                // Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n                // it to Base64, so this is how we store it to prevent very strange errors with less\n                // verbose ways of binary <-> string data storage.\n                var BASE_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n                var BLOB_TYPE_PREFIX = \"~~local_forage_type~\";\n                var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n                var SERIALIZED_MARKER = \"__lfsc__:\";\n                var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n                // OMG the serializations!\n                var TYPE_ARRAYBUFFER = \"arbf\";\n                var TYPE_BLOB = \"blob\";\n                var TYPE_INT8ARRAY = \"si08\";\n                var TYPE_UINT8ARRAY = \"ui08\";\n                var TYPE_UINT8CLAMPEDARRAY = \"uic8\";\n                var TYPE_INT16ARRAY = \"si16\";\n                var TYPE_INT32ARRAY = \"si32\";\n                var TYPE_UINT16ARRAY = \"ur16\";\n                var TYPE_UINT32ARRAY = \"ui32\";\n                var TYPE_FLOAT32ARRAY = \"fl32\";\n                var TYPE_FLOAT64ARRAY = \"fl64\";\n                var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n                var toString$1 = Object.prototype.toString;\n                function stringToBuffer(serializedString) {\n                    // Fill the string into a ArrayBuffer.\n                    var bufferLength = serializedString.length * 0.75;\n                    var len = serializedString.length;\n                    var i;\n                    var p = 0;\n                    var encoded1, encoded2, encoded3, encoded4;\n                    if (serializedString[serializedString.length - 1] === \"=\") {\n                        bufferLength--;\n                        if (serializedString[serializedString.length - 2] === \"=\") bufferLength--;\n                    }\n                    var buffer = new ArrayBuffer(bufferLength);\n                    var bytes = new Uint8Array(buffer);\n                    for(i = 0; i < len; i += 4){\n                        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n                        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n                        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n                        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n                        /*jslint bitwise: true */ bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n                        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n                        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n                    }\n                    return buffer;\n                }\n                // Converts a buffer to a string to store, serialized, in the backend\n                // storage library.\n                function bufferToString(buffer) {\n                    // base64-arraybuffer\n                    var bytes = new Uint8Array(buffer);\n                    var base64String = \"\";\n                    var i;\n                    for(i = 0; i < bytes.length; i += 3){\n                        /*jslint bitwise: true */ base64String += BASE_CHARS[bytes[i] >> 2];\n                        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n                        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n                        base64String += BASE_CHARS[bytes[i + 2] & 63];\n                    }\n                    if (bytes.length % 3 === 2) base64String = base64String.substring(0, base64String.length - 1) + \"=\";\n                    else if (bytes.length % 3 === 1) base64String = base64String.substring(0, base64String.length - 2) + \"==\";\n                    return base64String;\n                }\n                // Serialize a value, afterwards executing a callback (which usually\n                // instructs the `setItem()` callback/promise to be executed). This is how\n                // we store binary data with localStorage.\n                function serialize(value, callback) {\n                    var valueType = \"\";\n                    if (value) valueType = toString$1.call(value);\n                    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n                    // checks fail when running the tests using casper.js...\n                    //\n                    // TODO: See why those tests fail and use a better solution.\n                    if (value && (valueType === \"[object ArrayBuffer]\" || value.buffer && toString$1.call(value.buffer) === \"[object ArrayBuffer]\")) {\n                        // Convert binary arrays to a string and prefix the string with\n                        // a special marker.\n                        var buffer;\n                        var marker = SERIALIZED_MARKER;\n                        if (value instanceof ArrayBuffer) {\n                            buffer = value;\n                            marker += TYPE_ARRAYBUFFER;\n                        } else {\n                            buffer = value.buffer;\n                            if (valueType === \"[object Int8Array]\") marker += TYPE_INT8ARRAY;\n                            else if (valueType === \"[object Uint8Array]\") marker += TYPE_UINT8ARRAY;\n                            else if (valueType === \"[object Uint8ClampedArray]\") marker += TYPE_UINT8CLAMPEDARRAY;\n                            else if (valueType === \"[object Int16Array]\") marker += TYPE_INT16ARRAY;\n                            else if (valueType === \"[object Uint16Array]\") marker += TYPE_UINT16ARRAY;\n                            else if (valueType === \"[object Int32Array]\") marker += TYPE_INT32ARRAY;\n                            else if (valueType === \"[object Uint32Array]\") marker += TYPE_UINT32ARRAY;\n                            else if (valueType === \"[object Float32Array]\") marker += TYPE_FLOAT32ARRAY;\n                            else if (valueType === \"[object Float64Array]\") marker += TYPE_FLOAT64ARRAY;\n                            else callback(new Error(\"Failed to get type for BinaryArray\"));\n                        }\n                        callback(marker + bufferToString(buffer));\n                    } else if (valueType === \"[object Blob]\") {\n                        // Conver the blob to a binaryArray and then to a string.\n                        var fileReader = new FileReader();\n                        fileReader.onload = function() {\n                            // Backwards-compatible prefix for the blob type.\n                            var str = BLOB_TYPE_PREFIX + value.type + \"~\" + bufferToString(this.result);\n                            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n                        };\n                        fileReader.readAsArrayBuffer(value);\n                    } else try {\n                        callback(JSON.stringify(value));\n                    } catch (e) {\n                        console.error(\"Couldn't convert value into a JSON string: \", value);\n                        callback(null, e);\n                    }\n                }\n                // Deserialize data we've inserted into a value column/field. We place\n                // special markers into our strings to mark them as encoded; this isn't\n                // as nice as a meta field, but it's the only sane thing we can do whilst\n                // keeping localStorage support intact.\n                //\n                // Oftentimes this will just deserialize JSON content, but if we have a\n                // special marker (SERIALIZED_MARKER, defined above), we will extract\n                // some kind of arraybuffer/binary data/typed array out of the string.\n                function deserialize(value) {\n                    // If we haven't marked this string as being specially serialized (i.e.\n                    // something other than serialized JSON), we can just return it and be\n                    // done with it.\n                    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) return JSON.parse(value);\n                    // The following code deals with deserializing some kind of Blob or\n                    // TypedArray. First we separate out the type of data we're dealing\n                    // with from the data itself.\n                    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n                    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n                    var blobType;\n                    // Backwards-compatible blob type serialization strategy.\n                    // DBs created with older versions of localForage will simply not have the blob type.\n                    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n                        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n                        blobType = matcher[1];\n                        serializedString = serializedString.substring(matcher[0].length);\n                    }\n                    var buffer = stringToBuffer(serializedString);\n                    // Return the right type based on the code/type set during\n                    // serialization.\n                    switch(type){\n                        case TYPE_ARRAYBUFFER:\n                            return buffer;\n                        case TYPE_BLOB:\n                            return createBlob([\n                                buffer\n                            ], {\n                                type: blobType\n                            });\n                        case TYPE_INT8ARRAY:\n                            return new Int8Array(buffer);\n                        case TYPE_UINT8ARRAY:\n                            return new Uint8Array(buffer);\n                        case TYPE_UINT8CLAMPEDARRAY:\n                            return new Uint8ClampedArray(buffer);\n                        case TYPE_INT16ARRAY:\n                            return new Int16Array(buffer);\n                        case TYPE_UINT16ARRAY:\n                            return new Uint16Array(buffer);\n                        case TYPE_INT32ARRAY:\n                            return new Int32Array(buffer);\n                        case TYPE_UINT32ARRAY:\n                            return new Uint32Array(buffer);\n                        case TYPE_FLOAT32ARRAY:\n                            return new Float32Array(buffer);\n                        case TYPE_FLOAT64ARRAY:\n                            return new Float64Array(buffer);\n                        default:\n                            throw new Error(\"Unkown type: \" + type);\n                    }\n                }\n                var localforageSerializer = {\n                    serialize: serialize,\n                    deserialize: deserialize,\n                    stringToBuffer: stringToBuffer,\n                    bufferToString: bufferToString\n                };\n                /*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */ function createDbTable(t, dbInfo, callback, errorCallback) {\n                    t.executeSql(\"CREATE TABLE IF NOT EXISTS \" + dbInfo.storeName + \" \" + \"(id INTEGER PRIMARY KEY, key unique, value)\", [], callback, errorCallback);\n                }\n                // Open the WebSQL database (automatically creates one if one didn't\n                // previously exist), using any options set in the config.\n                function _initStorage$1(options) {\n                    var self1 = this;\n                    var dbInfo = {\n                        db: null\n                    };\n                    if (options) for(var i in options)dbInfo[i] = typeof options[i] !== \"string\" ? options[i].toString() : options[i];\n                    var dbInfoPromise = new Promise$1(function(resolve, reject) {\n                        // Open the database; the openDatabase API will automatically\n                        // create it for us if it doesn't exist.\n                        try {\n                            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n                        } catch (e) {\n                            return reject(e);\n                        }\n                        // Create our key/value table if it doesn't exist.\n                        dbInfo.db.transaction(function(t) {\n                            createDbTable(t, dbInfo, function() {\n                                self1._dbInfo = dbInfo;\n                                resolve();\n                            }, function(t, error) {\n                                reject(error);\n                            });\n                        }, reject);\n                    });\n                    dbInfo.serializer = localforageSerializer;\n                    return dbInfoPromise;\n                }\n                function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n                    t.executeSql(sqlStatement, args, callback, function(t, error) {\n                        if (error.code === error.SYNTAX_ERR) t.executeSql(\"SELECT name FROM sqlite_master WHERE type='table' AND name = ?\", [\n                            dbInfo.storeName\n                        ], function(t, results) {\n                            if (!results.rows.length) // if the table is missing (was deleted)\n                            // re-create it table and retry\n                            createDbTable(t, dbInfo, function() {\n                                t.executeSql(sqlStatement, args, callback, errorCallback);\n                            }, errorCallback);\n                            else errorCallback(t, error);\n                        }, errorCallback);\n                        else errorCallback(t, error);\n                    }, errorCallback);\n                }\n                function getItem$1(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT * FROM \" + dbInfo.storeName + \" WHERE key = ? LIMIT 1\", [\n                                    key\n                                ], function(t, results) {\n                                    var result = results.rows.length ? results.rows.item(0).value : null;\n                                    // Check to see if this is serialized content we need to\n                                    // unpack.\n                                    if (result) result = dbInfo.serializer.deserialize(result);\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function iterate$1(iterator, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT * FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var rows = results.rows;\n                                    var length = rows.length;\n                                    for(var i = 0; i < length; i++){\n                                        var item = rows.item(i);\n                                        var result = item.value;\n                                        // Check to see if this is serialized content\n                                        // we need to unpack.\n                                        if (result) result = dbInfo.serializer.deserialize(result);\n                                        result = iterator(result, item.key, i + 1);\n                                        // void(0) prevents problems with redefinition\n                                        // of `undefined`.\n                                        if (result !== void 0) {\n                                            resolve(result);\n                                            return;\n                                        }\n                                    }\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function _setItem(key, value, callback, retriesLeft) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            // The localStorage API doesn't return undefined values in an\n                            // \"expected\" way, so undefined is always cast to null in all\n                            // drivers. See: https://github.com/mozilla/localForage/pull/42\n                            if (value === undefined) value = null;\n                            // Save the original value to pass to the callback.\n                            var originalValue = value;\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.serializer.serialize(value, function(value, error) {\n                                if (error) reject(error);\n                                else dbInfo.db.transaction(function(t) {\n                                    tryExecuteSql(t, dbInfo, \"INSERT OR REPLACE INTO \" + dbInfo.storeName + \" \" + \"(key, value) VALUES (?, ?)\", [\n                                        key,\n                                        value\n                                    ], function() {\n                                        resolve(originalValue);\n                                    }, function(t, error) {\n                                        reject(error);\n                                    });\n                                }, function(sqlError) {\n                                    // The transaction failed; check\n                                    // to see if it's a quota error.\n                                    if (sqlError.code === sqlError.QUOTA_ERR) {\n                                        // We reject the callback outright for now, but\n                                        // it's worth trying to re-run the transaction.\n                                        // Even if the user accepts the prompt to use\n                                        // more storage on Safari, this error will\n                                        // be called.\n                                        //\n                                        // Try to re-run the transaction.\n                                        if (retriesLeft > 0) {\n                                            resolve(_setItem.apply(self1, [\n                                                key,\n                                                originalValue,\n                                                callback,\n                                                retriesLeft - 1\n                                            ]));\n                                            return;\n                                        }\n                                        reject(sqlError);\n                                    }\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function setItem$1(key, value, callback) {\n                    return _setItem.apply(this, [\n                        key,\n                        value,\n                        callback,\n                        1\n                    ]);\n                }\n                function removeItem$1(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"DELETE FROM \" + dbInfo.storeName + \" WHERE key = ?\", [\n                                    key\n                                ], function() {\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Deletes every item in the table.\n                // TODO: Find out if this resets the AUTO_INCREMENT number.\n                function clear$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"DELETE FROM \" + dbInfo.storeName, [], function() {\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Does a simple `COUNT(key)` to get the number of items stored in\n                // localForage.\n                function length$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                // Ahhh, SQL makes this one soooooo easy.\n                                tryExecuteSql(t, dbInfo, \"SELECT COUNT(key) as c FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var result = results.rows.item(0).c;\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Return the key located at key index X; essentially gets the key from a\n                // `WHERE id = ?`. This is the most efficient way I can think to implement\n                // this rarely-used (in my experience) part of the API, but it can seem\n                // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n                // the ID of each key will change every time it's updated. Perhaps a stored\n                // procedure for the `setItem()` SQL would solve this problem?\n                // TODO: Don't change ID on `setItem()`.\n                function key$1(n, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT key FROM \" + dbInfo.storeName + \" WHERE id = ? LIMIT 1\", [\n                                    n + 1\n                                ], function(t, results) {\n                                    var result = results.rows.length ? results.rows.item(0).key : null;\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT key FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var keys = [];\n                                    for(var i = 0; i < results.rows.length; i++)keys.push(results.rows.item(i).key);\n                                    resolve(keys);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // https://www.w3.org/TR/webdatabase/#databases\n                // > There is no way to enumerate or delete the databases available for an origin from this API.\n                function getAllStoreNames(db) {\n                    return new Promise$1(function(resolve, reject) {\n                        db.transaction(function(t) {\n                            t.executeSql(\"SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function(t, results) {\n                                var storeNames = [];\n                                for(var i = 0; i < results.rows.length; i++)storeNames.push(results.rows.item(i).name);\n                                resolve({\n                                    db: db,\n                                    storeNames: storeNames\n                                });\n                            }, function(t, error) {\n                                reject(error);\n                            });\n                        }, function(sqlError) {\n                            reject(sqlError);\n                        });\n                    });\n                }\n                function dropInstance$1(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    var currentConfig = this.config();\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) promise = Promise$1.reject(\"Invalid arguments\");\n                    else promise = new Promise$1(function(resolve) {\n                        var db;\n                        if (options.name === currentConfig.name) // use the db reference of the current instance\n                        db = self1._dbInfo.db;\n                        else db = openDatabase(options.name, \"\", \"\", 0);\n                        if (!options.storeName) // drop all database tables\n                        resolve(getAllStoreNames(db));\n                        else resolve({\n                            db: db,\n                            storeNames: [\n                                options.storeName\n                            ]\n                        });\n                    }).then(function(operationInfo) {\n                        return new Promise$1(function(resolve, reject) {\n                            operationInfo.db.transaction(function(t) {\n                                function dropTable(storeName) {\n                                    return new Promise$1(function(resolve, reject) {\n                                        t.executeSql(\"DROP TABLE IF EXISTS \" + storeName, [], function() {\n                                            resolve();\n                                        }, function(t, error) {\n                                            reject(error);\n                                        });\n                                    });\n                                }\n                                var operations = [];\n                                for(var i = 0, len = operationInfo.storeNames.length; i < len; i++)operations.push(dropTable(operationInfo.storeNames[i]));\n                                Promise$1.all(operations).then(function() {\n                                    resolve();\n                                })[\"catch\"](function(e) {\n                                    reject(e);\n                                });\n                            }, function(sqlError) {\n                                reject(sqlError);\n                            });\n                        });\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var webSQLStorage = {\n                    _driver: \"webSQLStorage\",\n                    _initStorage: _initStorage$1,\n                    _support: isWebSQLValid(),\n                    iterate: iterate$1,\n                    getItem: getItem$1,\n                    setItem: setItem$1,\n                    removeItem: removeItem$1,\n                    clear: clear$1,\n                    length: length$1,\n                    key: key$1,\n                    keys: keys$1,\n                    dropInstance: dropInstance$1\n                };\n                function isLocalStorageValid() {\n                    try {\n                        return typeof localStorage !== \"undefined\" && \"setItem\" in localStorage && // in IE8 typeof localStorage.setItem === 'object'\n                        !!localStorage.setItem;\n                    } catch (e) {\n                        return false;\n                    }\n                }\n                function _getKeyPrefix(options, defaultConfig) {\n                    var keyPrefix = options.name + \"/\";\n                    if (options.storeName !== defaultConfig.storeName) keyPrefix += options.storeName + \"/\";\n                    return keyPrefix;\n                }\n                // Check if localStorage throws when saving an item\n                function checkIfLocalStorageThrows() {\n                    var localStorageTestKey = \"_localforage_support_test\";\n                    try {\n                        localStorage.setItem(localStorageTestKey, true);\n                        localStorage.removeItem(localStorageTestKey);\n                        return false;\n                    } catch (e) {\n                        return true;\n                    }\n                }\n                // Check if localStorage is usable and allows to save an item\n                // This method checks if localStorage is usable in Safari Private Browsing\n                // mode, or in any other case where the available quota for localStorage\n                // is 0 and there wasn't any saved items yet.\n                function _isLocalStorageUsable() {\n                    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n                }\n                // Config the localStorage backend, using options set in the config.\n                function _initStorage$2(options) {\n                    var self1 = this;\n                    var dbInfo = {};\n                    if (options) for(var i in options)dbInfo[i] = options[i];\n                    dbInfo.keyPrefix = _getKeyPrefix(options, self1._defaultConfig);\n                    if (!_isLocalStorageUsable()) return Promise$1.reject();\n                    self1._dbInfo = dbInfo;\n                    dbInfo.serializer = localforageSerializer;\n                    return Promise$1.resolve();\n                }\n                // Remove all keys from the datastore, effectively destroying all data in\n                // the app's key/value store!\n                function clear$2(callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var keyPrefix = self1._dbInfo.keyPrefix;\n                        for(var i = localStorage.length - 1; i >= 0; i--){\n                            var key = localStorage.key(i);\n                            if (key.indexOf(keyPrefix) === 0) localStorage.removeItem(key);\n                        }\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Retrieve an item from the store. Unlike the original async_storage\n                // library in Gaia, we don't modify return values at all. If a key's value\n                // is `undefined`, we pass that value to the callback function.\n                function getItem$2(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n                        // If a result was found, parse it from the serialized\n                        // string into a JS object. If result isn't truthy, the key\n                        // is likely undefined and we'll pass it straight to the\n                        // callback.\n                        if (result) result = dbInfo.serializer.deserialize(result);\n                        return result;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Iterate over all items in the store.\n                function iterate$2(iterator, callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var keyPrefix = dbInfo.keyPrefix;\n                        var keyPrefixLength = keyPrefix.length;\n                        var length = localStorage.length;\n                        // We use a dedicated iterator instead of the `i` variable below\n                        // so other keys we fetch in localStorage aren't counted in\n                        // the `iterationNumber` argument passed to the `iterate()`\n                        // callback.\n                        //\n                        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n                        var iterationNumber = 1;\n                        for(var i = 0; i < length; i++){\n                            var key = localStorage.key(i);\n                            if (key.indexOf(keyPrefix) !== 0) continue;\n                            var value = localStorage.getItem(key);\n                            // If a result was found, parse it from the serialized\n                            // string into a JS object. If result isn't truthy, the\n                            // key is likely undefined and we'll pass it straight\n                            // to the iterator.\n                            if (value) value = dbInfo.serializer.deserialize(value);\n                            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n                            if (value !== void 0) return value;\n                        }\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Same as localStorage's key() method, except takes a callback.\n                function key$2(n, callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var result;\n                        try {\n                            result = localStorage.key(n);\n                        } catch (error) {\n                            result = null;\n                        }\n                        // Remove the prefix from the key, if a key is found.\n                        if (result) result = result.substring(dbInfo.keyPrefix.length);\n                        return result;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys$2(callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var length = localStorage.length;\n                        var keys = [];\n                        for(var i = 0; i < length; i++){\n                            var itemKey = localStorage.key(i);\n                            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n                        }\n                        return keys;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Supply the number of keys in the datastore to the callback function.\n                function length$2(callback) {\n                    var self1 = this;\n                    var promise = self1.keys().then(function(keys) {\n                        return keys.length;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Remove an item from the store, nice and simple.\n                function removeItem$2(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        localStorage.removeItem(dbInfo.keyPrefix + key);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Set a key's value and run an optional callback once the value is set.\n                // Unlike Gaia's implementation, the callback function is passed the value,\n                // in case you want to operate on that value only after you're sure it\n                // saved, or something like that.\n                function setItem$2(key, value, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        // Convert undefined values to null.\n                        // https://github.com/mozilla/localForage/pull/42\n                        if (value === undefined) value = null;\n                        // Save the original value to pass to the callback.\n                        var originalValue = value;\n                        return new Promise$1(function(resolve, reject) {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.serializer.serialize(value, function(value, error) {\n                                if (error) reject(error);\n                                else try {\n                                    localStorage.setItem(dbInfo.keyPrefix + key, value);\n                                    resolve(originalValue);\n                                } catch (e) {\n                                    // localStorage capacity exceeded.\n                                    // TODO: Make this a specific error/event.\n                                    if (e.name === \"QuotaExceededError\" || e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") reject(e);\n                                    reject(e);\n                                }\n                            });\n                        });\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function dropInstance$2(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        var currentConfig = this.config();\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) promise = Promise$1.reject(\"Invalid arguments\");\n                    else promise = new Promise$1(function(resolve) {\n                        if (!options.storeName) resolve(options.name + \"/\");\n                        else resolve(_getKeyPrefix(options, self1._defaultConfig));\n                    }).then(function(keyPrefix) {\n                        for(var i = localStorage.length - 1; i >= 0; i--){\n                            var key = localStorage.key(i);\n                            if (key.indexOf(keyPrefix) === 0) localStorage.removeItem(key);\n                        }\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var localStorageWrapper = {\n                    _driver: \"localStorageWrapper\",\n                    _initStorage: _initStorage$2,\n                    _support: isLocalStorageValid(),\n                    iterate: iterate$2,\n                    getItem: getItem$2,\n                    setItem: setItem$2,\n                    removeItem: removeItem$2,\n                    clear: clear$2,\n                    length: length$2,\n                    key: key$2,\n                    keys: keys$2,\n                    dropInstance: dropInstance$2\n                };\n                var sameValue = function sameValue(x, y) {\n                    return x === y || typeof x === \"number\" && typeof y === \"number\" && isNaN(x) && isNaN(y);\n                };\n                var includes = function includes(array, searchElement) {\n                    var len = array.length;\n                    var i = 0;\n                    while(i < len){\n                        if (sameValue(array[i], searchElement)) return true;\n                        i++;\n                    }\n                    return false;\n                };\n                var isArray = Array.isArray || function(arg) {\n                    return Object.prototype.toString.call(arg) === \"[object Array]\";\n                };\n                // Drivers are stored here when `defineDriver()` is called.\n                // They are shared across all instances of localForage.\n                var DefinedDrivers = {};\n                var DriverSupport = {};\n                var DefaultDrivers = {\n                    INDEXEDDB: asyncStorage,\n                    WEBSQL: webSQLStorage,\n                    LOCALSTORAGE: localStorageWrapper\n                };\n                var DefaultDriverOrder = [\n                    DefaultDrivers.INDEXEDDB._driver,\n                    DefaultDrivers.WEBSQL._driver,\n                    DefaultDrivers.LOCALSTORAGE._driver\n                ];\n                var OptionalDriverMethods = [\n                    \"dropInstance\"\n                ];\n                var LibraryMethods = [\n                    \"clear\",\n                    \"getItem\",\n                    \"iterate\",\n                    \"key\",\n                    \"keys\",\n                    \"length\",\n                    \"removeItem\",\n                    \"setItem\"\n                ].concat(OptionalDriverMethods);\n                var DefaultConfig = {\n                    description: \"\",\n                    driver: DefaultDriverOrder.slice(),\n                    name: \"localforage\",\n                    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n                    // we can use without a prompt.\n                    size: 4980736,\n                    storeName: \"keyvaluepairs\",\n                    version: 1.0\n                };\n                function callWhenReady(localForageInstance, libraryMethod) {\n                    localForageInstance[libraryMethod] = function() {\n                        var _args = arguments;\n                        return localForageInstance.ready().then(function() {\n                            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n                        });\n                    };\n                }\n                function extend() {\n                    for(var i = 1; i < arguments.length; i++){\n                        var arg = arguments[i];\n                        if (arg) {\n                            for(var _key in arg)if (arg.hasOwnProperty(_key)) {\n                                if (isArray(arg[_key])) arguments[0][_key] = arg[_key].slice();\n                                else arguments[0][_key] = arg[_key];\n                            }\n                        }\n                    }\n                    return arguments[0];\n                }\n                var LocalForage = function() {\n                    function LocalForage(options) {\n                        _classCallCheck(this, LocalForage);\n                        for(var driverTypeKey in DefaultDrivers)if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                            var driver = DefaultDrivers[driverTypeKey];\n                            var driverName = driver._driver;\n                            this[driverTypeKey] = driverName;\n                            if (!DefinedDrivers[driverName]) // we don't need to wait for the promise,\n                            // since the default drivers can be defined\n                            // in a blocking manner\n                            this.defineDriver(driver);\n                        }\n                        this._defaultConfig = extend({}, DefaultConfig);\n                        this._config = extend({}, this._defaultConfig, options);\n                        this._driverSet = null;\n                        this._initDriver = null;\n                        this._ready = false;\n                        this._dbInfo = null;\n                        this._wrapLibraryMethodsWithReady();\n                        this.setDriver(this._config.driver)[\"catch\"](function() {});\n                    }\n                    // Set any config values for localForage; can be called anytime before\n                    // the first API call (e.g. `getItem`, `setItem`).\n                    // We loop through options so we don't overwrite existing config\n                    // values.\n                    LocalForage.prototype.config = function config(options) {\n                        // If the options argument is an object, we use it to set values.\n                        // Otherwise, we return either a specified config value or all\n                        // config values.\n                        if ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) === \"object\") {\n                            // If localforage is ready and fully initialized, we can't set\n                            // any new configuration values. Instead, we return an error.\n                            if (this._ready) return new Error(\"Can't call config() after localforage has been used.\");\n                            for(var i in options){\n                                if (i === \"storeName\") options[i] = options[i].replace(/\\W/g, \"_\");\n                                if (i === \"version\" && typeof options[i] !== \"number\") return new Error(\"Database version must be a number.\");\n                                this._config[i] = options[i];\n                            }\n                            // after all config options are set and\n                            // the driver option is used, try setting it\n                            if (\"driver\" in options && options.driver) return this.setDriver(this._config.driver);\n                            return true;\n                        } else if (typeof options === \"string\") return this._config[options];\n                        else return this._config;\n                    };\n                    // Used to define a custom driver, shared across all instances of\n                    // localForage.\n                    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n                        var promise = new Promise$1(function(resolve, reject) {\n                            try {\n                                var driverName = driverObject._driver;\n                                var complianceError = new Error(\"Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver\");\n                                // A driver name should be defined and not overlap with the\n                                // library-defined, default drivers.\n                                if (!driverObject._driver) {\n                                    reject(complianceError);\n                                    return;\n                                }\n                                var driverMethods = LibraryMethods.concat(\"_initStorage\");\n                                for(var i = 0, len = driverMethods.length; i < len; i++){\n                                    var driverMethodName = driverMethods[i];\n                                    // when the property is there,\n                                    // it should be a method even when optional\n                                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== \"function\") {\n                                        reject(complianceError);\n                                        return;\n                                    }\n                                }\n                                var configureMissingMethods = function configureMissingMethods() {\n                                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                                        return function() {\n                                            var error = new Error(\"Method \" + methodName + \" is not implemented by the current driver\");\n                                            var promise = Promise$1.reject(error);\n                                            executeCallback(promise, arguments[arguments.length - 1]);\n                                            return promise;\n                                        };\n                                    };\n                                    for(var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++){\n                                        var optionalDriverMethod = OptionalDriverMethods[_i];\n                                        if (!driverObject[optionalDriverMethod]) driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                                    }\n                                };\n                                configureMissingMethods();\n                                var setDriverSupport = function setDriverSupport(support) {\n                                    if (DefinedDrivers[driverName]) console.info(\"Redefining LocalForage driver: \" + driverName);\n                                    DefinedDrivers[driverName] = driverObject;\n                                    DriverSupport[driverName] = support;\n                                    // don't use a then, so that we can define\n                                    // drivers that have simple _support methods\n                                    // in a blocking manner\n                                    resolve();\n                                };\n                                if (\"_support\" in driverObject) {\n                                    if (driverObject._support && typeof driverObject._support === \"function\") driverObject._support().then(setDriverSupport, reject);\n                                    else setDriverSupport(!!driverObject._support);\n                                } else setDriverSupport(true);\n                            } catch (e) {\n                                reject(e);\n                            }\n                        });\n                        executeTwoCallbacks(promise, callback, errorCallback);\n                        return promise;\n                    };\n                    LocalForage.prototype.driver = function driver() {\n                        return this._driver || null;\n                    };\n                    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n                        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error(\"Driver not found.\"));\n                        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n                        return getDriverPromise;\n                    };\n                    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n                        var serializerPromise = Promise$1.resolve(localforageSerializer);\n                        executeTwoCallbacks(serializerPromise, callback);\n                        return serializerPromise;\n                    };\n                    LocalForage.prototype.ready = function ready(callback) {\n                        var self1 = this;\n                        var promise = self1._driverSet.then(function() {\n                            if (self1._ready === null) self1._ready = self1._initDriver();\n                            return self1._ready;\n                        });\n                        executeTwoCallbacks(promise, callback, callback);\n                        return promise;\n                    };\n                    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n                        var self1 = this;\n                        if (!isArray(drivers)) drivers = [\n                            drivers\n                        ];\n                        var supportedDrivers = this._getSupportedDrivers(drivers);\n                        function setDriverToConfig() {\n                            self1._config.driver = self1.driver();\n                        }\n                        function extendSelfWithDriver(driver) {\n                            self1._extend(driver);\n                            setDriverToConfig();\n                            self1._ready = self1._initStorage(self1._config);\n                            return self1._ready;\n                        }\n                        function initDriver(supportedDrivers) {\n                            return function() {\n                                var currentDriverIndex = 0;\n                                function driverPromiseLoop() {\n                                    while(currentDriverIndex < supportedDrivers.length){\n                                        var driverName = supportedDrivers[currentDriverIndex];\n                                        currentDriverIndex++;\n                                        self1._dbInfo = null;\n                                        self1._ready = null;\n                                        return self1.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                                    }\n                                    setDriverToConfig();\n                                    var error = new Error(\"No available storage method found.\");\n                                    self1._driverSet = Promise$1.reject(error);\n                                    return self1._driverSet;\n                                }\n                                return driverPromiseLoop();\n                            };\n                        }\n                        // There might be a driver initialization in progress\n                        // so wait for it to finish in order to avoid a possible\n                        // race condition to set _dbInfo\n                        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function() {\n                            return Promise$1.resolve();\n                        }) : Promise$1.resolve();\n                        this._driverSet = oldDriverSetDone.then(function() {\n                            var driverName = supportedDrivers[0];\n                            self1._dbInfo = null;\n                            self1._ready = null;\n                            return self1.getDriver(driverName).then(function(driver) {\n                                self1._driver = driver._driver;\n                                setDriverToConfig();\n                                self1._wrapLibraryMethodsWithReady();\n                                self1._initDriver = initDriver(supportedDrivers);\n                            });\n                        })[\"catch\"](function() {\n                            setDriverToConfig();\n                            var error = new Error(\"No available storage method found.\");\n                            self1._driverSet = Promise$1.reject(error);\n                            return self1._driverSet;\n                        });\n                        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n                        return this._driverSet;\n                    };\n                    LocalForage.prototype.supports = function supports(driverName) {\n                        return !!DriverSupport[driverName];\n                    };\n                    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n                        extend(this, libraryMethodsAndProperties);\n                    };\n                    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n                        var supportedDrivers = [];\n                        for(var i = 0, len = drivers.length; i < len; i++){\n                            var driverName = drivers[i];\n                            if (this.supports(driverName)) supportedDrivers.push(driverName);\n                        }\n                        return supportedDrivers;\n                    };\n                    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n                        // Add a stub for each driver API method that delays the call to the\n                        // corresponding driver method until localForage is ready. These stubs\n                        // will be replaced by the driver methods as soon as the driver is\n                        // loaded, so there is no performance impact.\n                        for(var i = 0, len = LibraryMethods.length; i < len; i++)callWhenReady(this, LibraryMethods[i]);\n                    };\n                    LocalForage.prototype.createInstance = function createInstance(options) {\n                        return new LocalForage(options);\n                    };\n                    return LocalForage;\n                }();\n                // The actual localForage object that we expose as a module or via a\n                // global. It's extended by pulling in one of our other libraries.\n                var localforage_js = new LocalForage();\n                module1.exports = localforage_js;\n            },\n            {\n                \"3\": 3\n            }\n        ]\n    }, {}, [\n        4\n    ])(4);\n});\n\n\nvar $c462483f4352d3f9$exports = {};\n\"use strict\";\n\n$c462483f4352d3f9$exports = (parcelRequire(\"enmjz\"));\n\n\n(0, (/*@__PURE__*/$parcel$interopDefault($a189fc184070e3b9$exports))).config({\n    driver: (0, (/*@__PURE__*/$parcel$interopDefault($a189fc184070e3b9$exports))).INDEXEDDB,\n    name: \"exercise-studio\",\n    version: 1.0\n});\nconst $f86d19e70b42d506$var$FS_KEY = \"DIRECTORY_HANDLES\";\nfunction $f86d19e70b42d506$export$f6a75fa8126b503b(d) {\n    (0, (/*@__PURE__*/$parcel$interopDefault($a189fc184070e3b9$exports))).setItem($f86d19e70b42d506$var$FS_KEY, d);\n}\nfunction $f86d19e70b42d506$export$677e98969b64a26c() {\n    return (0, (/*@__PURE__*/$parcel$interopDefault($a189fc184070e3b9$exports))).getItem($f86d19e70b42d506$var$FS_KEY);\n}\n\n\n// @ts-ignore\nconst $fb1bb2d850b60f11$var$DEBUG = false;\nfunction $fb1bb2d850b60f11$var$debug(...message) {\n    if ($fb1bb2d850b60f11$var$DEBUG) console.log(...message);\n}\nconst $fb1bb2d850b60f11$var$runtimeStorage = {\n    handles: []\n};\n/* MAKE STUFF AVAILABLE OFFLINE */ async function $fb1bb2d850b60f11$var$installCaches() {\n    if ($fb1bb2d850b60f11$var$DEBUG === true) return;\n    const cache = await caches.open((0, $ca07057eef1ab6c2$export$83d89fbfd8236492));\n    $fb1bb2d850b60f11$var$debug({\n        manifest: $ca07057eef1ab6c2$export$e538f94cc8cf4db8\n    });\n    await cache.addAll((0, $ca07057eef1ab6c2$export$e538f94cc8cf4db8));\n}\nself.addEventListener(\"install\", (e)=>e.waitUntil($fb1bb2d850b60f11$var$installCaches()));\nasync function $fb1bb2d850b60f11$var$activate() {\n    const keys = await caches.keys();\n    await Promise.all([\n        ...keys.map((key)=>key !== (0, $ca07057eef1ab6c2$export$83d89fbfd8236492) && caches.delete(key)),\n        self.clients.claim()\n    ]);\n}\nself.addEventListener(\"activate\", (e)=>e.waitUntil($fb1bb2d850b60f11$var$activate()));\nself.addEventListener(\"fetch\", function(event) {\n    const runFetch = (cache)=>fetch(event.request).then(function(response) {\n            cache?.put(event.request, response.clone());\n            return response;\n        });\n    event.respondWith(caches.open((0, $ca07057eef1ab6c2$export$83d89fbfd8236492)).then(function(cache) {\n        return cache.match(event.request).then(function(response) {\n            $fb1bb2d850b60f11$var$debug(\"Network\", {\n                response: response,\n                request: event.request\n            });\n            return $fb1bb2d850b60f11$var$DEBUG ? runFetch() : response || runFetch(cache);\n        });\n    }));\n});\nself.addEventListener(\"message\", async (e)=>{\n    const message = e.data;\n    const response = await $fb1bb2d850b60f11$var$getActionAndResponse(message);\n    $fb1bb2d850b60f11$var$debug({\n        received: message,\n        response: response\n    });\n    if (response) e.source?.postMessage(response);\n});\nasync function $fb1bb2d850b60f11$var$getActionAndResponse(query) {\n    switch(query.type){\n        case \"StoreFSHandle\":\n            const handleMatches = await Promise.all($fb1bb2d850b60f11$var$runtimeStorage.handles.map((h)=>h.isSameEntry(query.data)));\n            if (handleMatches.includes(true) === false) {\n                $fb1bb2d850b60f11$var$runtimeStorage.handles.push(query.data);\n                (0, $f86d19e70b42d506$export$f6a75fa8126b503b)($fb1bb2d850b60f11$var$runtimeStorage.handles);\n            }\n            return;\n        case \"RequestFSHandles\":\n            $fb1bb2d850b60f11$var$runtimeStorage.handles = await (0, $f86d19e70b42d506$export$677e98969b64a26c)() ?? [];\n            if ($fb1bb2d850b60f11$var$runtimeStorage.handles.length > 0) return {\n                type: \"FSHandles\",\n                data: $fb1bb2d850b60f11$var$runtimeStorage.handles\n            };\n            return;\n    }\n    return undefined;\n}\n\n})();\n//# sourceMappingURL=sw.js.map\n","/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var l=Symbol.for(\"react.element\"),n=Symbol.for(\"react.portal\"),p=Symbol.for(\"react.fragment\"),q=Symbol.for(\"react.strict_mode\"),r=Symbol.for(\"react.profiler\"),t=Symbol.for(\"react.provider\"),u=Symbol.for(\"react.context\"),v=Symbol.for(\"react.forward_ref\"),w=Symbol.for(\"react.suspense\"),x=Symbol.for(\"react.memo\"),y=Symbol.for(\"react.lazy\"),z=Symbol.iterator;function A(a){if(null===a||\"object\"!==typeof a)return null;a=z&&a[z]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}\nvar B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};\nE.prototype.setState=function(a,b){if(\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a)throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");this.updater.enqueueSetState(this,a,b,\"setState\")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;\nH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=\"\"+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\nfunction N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={\"=\":\"=0\",\":\":\"=2\"};return\"$\"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return\"object\"===typeof a&&null!==a&&null!=a.key?escape(\"\"+a.key):b.toString(36)}\nfunction R(a,b,e,d,c){var k=typeof a;if(\"undefined\"===k||\"boolean\"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case \"string\":case \"number\":h=!0;break;case \"object\":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=\"\"===d?\".\"+Q(h,0):d,I(c)?(e=\"\",null!=a&&(e=a.replace(P,\"$&/\")+\"/\"),R(c,b,e,\"\",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?\"\":(\"\"+c.key).replace(P,\"$&/\")+\"/\")+a)),b.push(c)),1;h=0;d=\"\"===d?\".\":d+\":\";if(I(a))for(var g=0;g<a.length;g++){k=\na[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),\"function\"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if(\"object\"===k)throw b=String(a),Error(\"Objects are not valid as a React child (found: \"+(\"[object Object]\"===b?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":b)+\"). If you meant to render a collection of children, use an array instead.\");return h}\nfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,\"\",\"\",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}\nvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error(\"React.Children.only expected to receive a single React element child.\");return a}};exports.Component=E;exports.Fragment=p;\nexports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;\nexports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \"+a+\".\");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=\"\"+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\nfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};\nexports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=function(){throw Error(\"act(...) is not supported in production builds of React.\");};\nexports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};\nexports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};\nexports.useTransition=function(){return U.current.useTransition()};exports.version=\"18.2.0\";\n","import {_register} from '@parcel/service-worker';\nconst manifest = [\"index.html\",\"favicon.47681ad3.ico\",\"site.webmanifest\",\"icon-l.7082b16d.png\",\"index.d1655808.js\",\"index.6134c3ca.css\",\"index.476326c1.js\"];\nconst version = \"dfe300a7\";\n_register(manifest, version);\n","export let manifest = [];\nexport let version = '';\n\n// Called by the runtime.\nexport function _register(m, v) {\n  manifest = m;\n  version = v;\n}\n","/// <reference lib=\"WebWorker\" />\n\n// export empty type because of tsc --isolatedModules flag\nexport type {};\ndeclare const self: ServiceWorkerGlobalScope;\nimport { manifest, version } from \"@parcel/service-worker\";\n\nimport { MessageToSW, MessageFromSW } from \"./ts/helpers/serviceWorkerTools\";\nimport { storeHandle, getHandle } from \"./ts/helpers/storage\";\n\n// @ts-ignore\nconst DEBUG = process.env.NODE_ENV === \"development\";\n\nfunction debug(...message: unknown[]) {\n  if (DEBUG) {\n    console.log(...message);\n  }\n}\n\nconst runtimeStorage = {\n  handles: [] as FileSystemDirectoryHandle[],\n};\n\n/* MAKE STUFF AVAILABLE OFFLINE */\nasync function installCaches() {\n  if (DEBUG === true) {\n    return;\n  }\n  const cache = await caches.open(version);\n  debug({ manifest });\n  await cache.addAll(manifest);\n}\nself.addEventListener(\"install\", (e) => e.waitUntil(installCaches()));\n\nasync function activate() {\n  const keys = await caches.keys();\n  await Promise.all([\n    ...keys.map((key) => key !== version && caches.delete(key)),\n    self.clients.claim(),\n  ]);\n}\n\nself.addEventListener(\"activate\", (e) => e.waitUntil(activate()));\n\nself.addEventListener(\"fetch\", function (event) {\n  const runFetch = (cache?: Cache) =>\n    fetch(event.request).then(function (response) {\n      cache?.put(event.request, response.clone());\n      return response;\n    });\n\n  event.respondWith(\n    caches.open(version).then(function (cache) {\n      return cache.match(event.request).then(function (response) {\n        debug(\"Network\", { response, request: event.request });\n        return DEBUG ? runFetch() : response || runFetch(cache);\n      });\n    }),\n  );\n});\n\nself.addEventListener(\"message\", async (e) => {\n  const message = e.data as MessageToSW;\n  const response = await getActionAndResponse(message);\n  debug({ received: message, response });\n  if (response) {\n    e.source?.postMessage(response);\n  }\n});\n\nasync function getActionAndResponse(\n  query: MessageToSW,\n): Promise<MessageFromSW | undefined> {\n  switch (query.type) {\n    case \"StoreFSHandle\":\n      const handleMatches = await Promise.all(\n        runtimeStorage.handles.map((h) => h.isSameEntry(query.data)),\n      );\n      if (handleMatches.includes(true) === false) {\n        runtimeStorage.handles.push(query.data);\n        storeHandle(runtimeStorage.handles);\n      }\n      return;\n    case \"RequestFSHandles\":\n      runtimeStorage.handles = (await getHandle()) ?? [];\n      if (runtimeStorage.handles.length > 0) {\n        return { type: \"FSHandles\", data: runtimeStorage.handles };\n      }\n      return;\n  }\n\n  return undefined as never;\n}\n","import localforage from \"localforage\";\nimport React from \"react\";\n\nlocalforage.config({\n  driver: localforage.INDEXEDDB,\n  name: \"exercise-studio\",\n  version: 1.0,\n});\n\nconst FS_KEY = \"DIRECTORY_HANDLES\";\n\nexport function storeHandle(d: FileSystemDirectoryHandle[]) {\n  localforage.setItem(FS_KEY, d);\n}\n\nexport function getHandle() {\n  return localforage.getItem<FileSystemDirectoryHandle[]>(FS_KEY)\n}","/*!\n    localForage -- Offline Storage, Improved\n    Version 1.10.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {\n        return;\n    }\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb || !idb.open) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support\n        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n        // Safari 10.1 shipped with fetch, we can use that to detect it.\n        // Note: this creates issues with `window.fetch` polyfills and\n        // overrides; see:\n        // https://github.com/localForage/localForage/issues/856\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        // See: https://github.com/mozilla/localForage/issues/128\n        // See: https://github.com/mozilla/localForage/issues/272\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\nfunction normalizeKey(key) {\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    return key;\n}\n\nfunction getCallback() {\n    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n        return arguments[arguments.length - 1];\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs = void 0;\nvar dbContexts = {};\nvar toString = Object.prototype.toString;\n\n// Transaction Modes\nvar READ_ONLY = 'readonly';\nvar READ_WRITE = 'readwrite';\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve, reject) {\n        deferredOperation.resolve = resolve;\n        deferredOperation.reject = reject;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n        return deferredOperation.promise;\n    }\n}\n\nfunction _rejectReadiness(dbInfo, err) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Reject its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.reject(err);\n        return deferredOperation.promise;\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            var db = openreq.result;\n            db.onversionchange = function (e) {\n                // Triggered when the database is modified (e.g. adding an objectStore) or\n                // deleted (even when initiated by other sessions in different tabs).\n                // Closing the connection here prevents those operations from being blocked.\n                // If the database is accessed again later by this instance, the connection\n                // will be reopened or the database recreated as needed.\n                e.target.close();\n            };\n            resolve(db);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Try to establish a new db connection to replace the\n// current one which is broken (i.e. experiencing\n// InvalidStateError while creating a transaction).\nfunction _tryReconnect(dbInfo) {\n    _deferReadiness(dbInfo);\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    for (var i = 0; i < forages.length; i++) {\n        var forage = forages[i];\n        if (forage._dbInfo.db) {\n            forage._dbInfo.db.close();\n            forage._dbInfo.db = null;\n        }\n    }\n    dbInfo.db = null;\n\n    return _getOriginalConnection(dbInfo).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        // store the latest db reference\n        // in case the db was upgraded\n        dbInfo.db = dbContext.db = db;\n        for (var i = 0; i < forages.length; i++) {\n            forages[i]._dbInfo.db = db;\n        }\n    })[\"catch\"](function (err) {\n        _rejectReadiness(dbInfo, err);\n        throw err;\n    });\n}\n\n// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n// so we have to do it with callbacks\nfunction createTransaction(dbInfo, mode, callback, retries) {\n    if (retries === undefined) {\n        retries = 1;\n    }\n\n    try {\n        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n        callback(null, tx);\n    } catch (err) {\n        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\n            return Promise$1.resolve().then(function () {\n                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                    // increase the db version, to create the new ObjectStore\n                    if (dbInfo.db) {\n                        dbInfo.version = dbInfo.db.version + 1;\n                    }\n                    // Reopen the database for upgrading.\n                    return _getUpgradedConnection(dbInfo);\n                }\n            }).then(function () {\n                return _tryReconnect(dbInfo).then(function () {\n                    createTransaction(dbInfo, mode, callback, retries - 1);\n                });\n            })[\"catch\"](callback);\n        }\n\n        callback(err);\n    }\n}\n\nfunction createDbContext() {\n    return {\n        // Running localForages sharing a database.\n        forages: [],\n        // Shared database.\n        db: null,\n        // Database readiness (promise).\n        dbReady: null,\n        // Deferred operations on the database.\n        deferredOperations: []\n    };\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = createDbContext();\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.get(key);\n\n                    req.onsuccess = function () {\n                        var value = req.result;\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        if (_isEncodedBlob(value)) {\n                            value = _decodeBlob(value);\n                        }\n                        resolve(value);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var iterationNumber = 1;\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (cursor) {\n                            var value = cursor.value;\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            var result = iterator(value, cursor.key, iterationNumber++);\n\n                            // when the iterator callback returns any\n                            // (non-`undefined`) value, then we stop\n                            // the iteration immediately\n                            if (result !== void 0) {\n                                resolve(result);\n                            } else {\n                                cursor[\"continue\"]();\n                            }\n                        } else {\n                            resolve();\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n\n                    // The reason we don't _save_ null is because IE 10 does\n                    // not support saving the `null` type in IndexedDB. How\n                    // ironic, given the bug below!\n                    // See: https://github.com/mozilla/localForage/issues/161\n                    if (value === null) {\n                        value = undefined;\n                    }\n\n                    var req = store.put(value, key);\n\n                    transaction.oncomplete = function () {\n                        // Cast to undefined so the value passed to\n                        // callback/promise is the same as what one would get out\n                        // of `getItem()` later. This leads to some weirdness\n                        // (setItem('foo', undefined) will return `null`), but\n                        // it's not my fault localStorage is our baseline and that\n                        // it's weird.\n                        if (value === undefined) {\n                            value = null;\n                        }\n\n                        resolve(value);\n                    };\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    // We use a Grunt task to make this safe for IE and some\n                    // versions of Android (including those used by Cordova).\n                    // Normally IE won't like `.delete()` and will insist on\n                    // using `['delete']()`, but we have a build step that\n                    // fixes this for us now.\n                    var req = store[\"delete\"](key);\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onerror = function () {\n                        reject(req.error);\n                    };\n\n                    // The request will be also be aborted if we've exceeded our storage\n                    // space.\n                    transaction.onabort = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.clear();\n\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.count();\n\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var advanced = false;\n                    var req = store.openKeyCursor();\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            // this means there weren't enough keys\n                            resolve(null);\n\n                            return;\n                        }\n\n                        if (n === 0) {\n                            // We have the first key, return it if that's what they\n                            // wanted.\n                            resolve(cursor.key);\n                        } else {\n                            if (!advanced) {\n                                // Otherwise, ask the cursor to skip ahead n\n                                // records.\n                                advanced = true;\n                                cursor.advance(n);\n                            } else {\n                                // When we get here, we've got the nth key.\n                                resolve(cursor.key);\n                            }\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openKeyCursor();\n                    var keys = [];\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (!cursor) {\n                            resolve(keys);\n                            return;\n                        }\n\n                        keys.push(cursor.key);\n                        cursor[\"continue\"]();\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\n\n        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {\n            var dbContext = dbContexts[options.name];\n            var forages = dbContext.forages;\n            dbContext.db = db;\n            for (var i = 0; i < forages.length; i++) {\n                forages[i]._dbInfo.db = db;\n            }\n            return db;\n        });\n\n        if (!options.storeName) {\n            promise = dbPromise.then(function (db) {\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                }\n\n                var dropDBPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.deleteDatabase(options.name);\n\n                    req.onerror = function () {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        reject(req.error);\n                    };\n\n                    req.onblocked = function () {\n                        // Closing all open connections in onversionchange handler should prevent this situation, but if\n                        // we do get here, it just means the request remains pending - eventually it will succeed or error\n                        console.warn('dropInstance blocked for database \"' + options.name + '\" until all open connections are closed');\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        resolve(db);\n                    };\n                });\n\n                return dropDBPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var i = 0; i < forages.length; i++) {\n                        var _forage = forages[i];\n                        _advanceReadiness(_forage._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        } else {\n            promise = dbPromise.then(function (db) {\n                if (!db.objectStoreNames.contains(options.storeName)) {\n                    return;\n                }\n\n                var newVersion = db.version + 1;\n\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                    forage._dbInfo.version = newVersion;\n                }\n\n                var dropObjectPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.open(options.name, newVersion);\n\n                    req.onerror = function (err) {\n                        var db = req.result;\n                        db.close();\n                        reject(err);\n                    };\n\n                    req.onupgradeneeded = function () {\n                        var db = req.result;\n                        db.deleteObjectStore(options.storeName);\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        db.close();\n                        resolve(db);\n                    };\n                });\n\n                return dropObjectPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var j = 0; j < forages.length; j++) {\n                        var _forage2 = forages[j];\n                        _forage2._dbInfo.db = db;\n                        _advanceReadiness(_forage2._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        }\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    _support: isIndexedDBValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys,\n    dropInstance: dropInstance\n};\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nfunction createDbTable(t, dbInfo, callback, errorCallback) {\n    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\n}\n\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            createDbTable(t, dbInfo, function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        }, reject);\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n    t.executeSql(sqlStatement, args, callback, function (t, error) {\n        if (error.code === error.SYNTAX_ERR) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [dbInfo.storeName], function (t, results) {\n                if (!results.rows.length) {\n                    // if the table is missing (was deleted)\n                    // re-create it table and retry\n                    createDbTable(t, dbInfo, function () {\n                        t.executeSql(sqlStatement, args, callback, errorCallback);\n                    }, errorCallback);\n                } else {\n                    errorCallback(t, error);\n                }\n            }, errorCallback);\n        } else {\n            errorCallback(t, error);\n        }\n    }, errorCallback);\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// https://www.w3.org/TR/webdatabase/#databases\n// > There is no way to enumerate or delete the databases available for an origin from this API.\nfunction getAllStoreNames(db) {\n    return new Promise$1(function (resolve, reject) {\n        db.transaction(function (t) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\n                var storeNames = [];\n\n                for (var i = 0; i < results.rows.length; i++) {\n                    storeNames.push(results.rows.item(i).name);\n                }\n\n                resolve({\n                    db: db,\n                    storeNames: storeNames\n                });\n            }, function (t, error) {\n                reject(error);\n            });\n        }, function (sqlError) {\n            reject(sqlError);\n        });\n    });\n}\n\nfunction dropInstance$1(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            var db;\n            if (options.name === currentConfig.name) {\n                // use the db reference of the current instance\n                db = self._dbInfo.db;\n            } else {\n                db = openDatabase(options.name, '', '', 0);\n            }\n\n            if (!options.storeName) {\n                // drop all database tables\n                resolve(getAllStoreNames(db));\n            } else {\n                resolve({\n                    db: db,\n                    storeNames: [options.storeName]\n                });\n            }\n        }).then(function (operationInfo) {\n            return new Promise$1(function (resolve, reject) {\n                operationInfo.db.transaction(function (t) {\n                    function dropTable(storeName) {\n                        return new Promise$1(function (resolve, reject) {\n                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {\n                                resolve();\n                            }, function (t, error) {\n                                reject(error);\n                            });\n                        });\n                    }\n\n                    var operations = [];\n                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\n                        operations.push(dropTable(operationInfo.storeNames[i]));\n                    }\n\n                    Promise$1.all(operations).then(function () {\n                        resolve();\n                    })[\"catch\"](function (e) {\n                        reject(e);\n                    });\n                }, function (sqlError) {\n                    reject(sqlError);\n                });\n            });\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    _support: isWebSQLValid(),\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1,\n    dropInstance: dropInstance$1\n};\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&\n        // in IE8 typeof localStorage.setItem === 'object'\n        !!localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction _getKeyPrefix(options, defaultConfig) {\n    var keyPrefix = options.name + '/';\n\n    if (options.storeName !== defaultConfig.storeName) {\n        keyPrefix += options.storeName + '/';\n    }\n    return keyPrefix;\n}\n\n// Check if localStorage throws when saving an item\nfunction checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\n// Check if localStorage is usable and allows to save an item\n// This method checks if localStorage is usable in Safari Private Browsing\n// mode, or in any other case where the available quota for localStorage\n// is 0 and there wasn't any saved items yet.\nfunction _isLocalStorageUsable() {\n    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n}\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n\n    if (!_isLocalStorageUsable()) {\n        return Promise$1.reject();\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance$2(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        var currentConfig = this.config();\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            if (!options.storeName) {\n                resolve(options.name + '/');\n            } else {\n                resolve(_getKeyPrefix(options, self._defaultConfig));\n            }\n        }).then(function (keyPrefix) {\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n                var key = localStorage.key(i);\n\n                if (key.indexOf(keyPrefix) === 0) {\n                    localStorage.removeItem(key);\n                }\n            }\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    _support: isLocalStorageValid(),\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2,\n    dropInstance: dropInstance$2\n};\n\nvar sameValue = function sameValue(x, y) {\n    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n};\n\nvar includes = function includes(array, searchElement) {\n    var len = array.length;\n    var i = 0;\n    while (i < len) {\n        if (sameValue(array[i], searchElement)) {\n            return true;\n        }\n        i++;\n    }\n\n    return false;\n};\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\n// Drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar DefinedDrivers = {};\n\nvar DriverSupport = {};\n\nvar DefaultDrivers = {\n    INDEXEDDB: asyncStorage,\n    WEBSQL: webSQLStorage,\n    LOCALSTORAGE: localStorageWrapper\n};\n\nvar DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n\nvar OptionalDriverMethods = ['dropInstance'];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var _key in arg) {\n                if (arg.hasOwnProperty(_key)) {\n                    if (isArray(arg[_key])) {\n                        arguments[0][_key] = arg[_key].slice();\n                    } else {\n                        arguments[0][_key] = arg[_key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        for (var driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                var driver = DefaultDrivers[driverTypeKey];\n                var driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                    // we don't need to wait for the promise,\n                    // since the default drivers can be defined\n                    // in a blocking manner\n                    this.defineDriver(driver);\n                }\n            }\n        }\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n\n                var driverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0, len = driverMethods.length; i < len; i++) {\n                    var driverMethodName = driverMethods[i];\n\n                    // when the property is there,\n                    // it should be a method even when optional\n                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var configureMissingMethods = function configureMissingMethods() {\n                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                        return function () {\n                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');\n                            var promise = Promise$1.reject(error);\n                            executeCallback(promise, arguments[arguments.length - 1]);\n                            return promise;\n                        };\n                    };\n\n                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {\n                        var optionalDriverMethod = OptionalDriverMethods[_i];\n                        if (!driverObject[optionalDriverMethod]) {\n                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                        }\n                    }\n                };\n\n                configureMissingMethods();\n\n                var setDriverSupport = function setDriverSupport(support) {\n                    if (DefinedDrivers[driverName]) {\n                        console.info('Redefining LocalForage driver: ' + driverName);\n                    }\n                    DefinedDrivers[driverName] = driverObject;\n                    DriverSupport[driverName] = support;\n                    // don't use a then, so that we can define\n                    // drivers that have simple _support methods\n                    // in a blocking manner\n                    resolve();\n                };\n\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        driverObject._support().then(setDriverSupport, reject);\n                    } else {\n                        setDriverSupport(!!driverObject._support);\n                    }\n                } else {\n                    setDriverSupport(true);\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!DriverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$a77485e72fcbbe24$export$dca3b0875bd9a954","$a77485e72fcbbe24$export$16fa2f45be04daa8","$a77485e72fcbbe24$export$ffb0004e005737fa","$a77485e72fcbbe24$export$e2c29f18771995cb","$a77485e72fcbbe24$export$221d75b3f55bb0bd","$a77485e72fcbbe24$export$5f8d39834fd61797","$a77485e72fcbbe24$export$74bf444e3cd11ea5","$a77485e72fcbbe24$export$ae55be85d98224ed","$a77485e72fcbbe24$export$e530037191fcd5d7","$a77485e72fcbbe24$export$fd42f52fd3ae1109","$a77485e72fcbbe24$export$c8a8987d4410bf2d","$a77485e72fcbbe24$export$d38cd72104c1f0e9","$a77485e72fcbbe24$export$7d1e3a5e95ceca43","$a77485e72fcbbe24$export$257a8862b851cb5b","$a77485e72fcbbe24$export$a8257692ac88316c","$a77485e72fcbbe24$export$488013bae63b21da","$a77485e72fcbbe24$export$7c73462e0d25e514","$a77485e72fcbbe24$export$7568632d0d33d16d","$a77485e72fcbbe24$export$88948ce120ea2619","$a77485e72fcbbe24$export$35808ee640e87ca7","$a77485e72fcbbe24$export$fae74005e78b1a27","$a77485e72fcbbe24$export$dc8fbce3eb94dc1e","$a77485e72fcbbe24$export$6a7bc4e911dc01cf","$a77485e72fcbbe24$export$6d9c69b0de29b591","$a77485e72fcbbe24$export$f680877a34711e37","$a77485e72fcbbe24$export$d5a552a76deda3c2","$a77485e72fcbbe24$export$aaabe4eda9ed9969","$a77485e72fcbbe24$export$e5c5a5f917a5871c","$a77485e72fcbbe24$export$1538c33de8887b59","$a77485e72fcbbe24$export$13e3392192263954","$a77485e72fcbbe24$export$b8f5890fc79d6aca","$a77485e72fcbbe24$export$60241385465d0a34","$a77485e72fcbbe24$export$306c0aa65ff9ec16","$a77485e72fcbbe24$export$7b286972b8d8ccbf","$a77485e72fcbbe24$export$83d89fbfd8236492","$a77485e72fcbbe24$var$l","Symbol","for","$a77485e72fcbbe24$var$n","$a77485e72fcbbe24$var$p","$a77485e72fcbbe24$var$q","$a77485e72fcbbe24$var$r","$a77485e72fcbbe24$var$t","$a77485e72fcbbe24$var$u","$a77485e72fcbbe24$var$v","$a77485e72fcbbe24$var$w","$a77485e72fcbbe24$var$x","$a77485e72fcbbe24$var$y","$a77485e72fcbbe24$var$z","iterator","$a77485e72fcbbe24$var$B","isMounted","enqueueForceUpdate","enqueueReplaceState","enqueueSetState","$a77485e72fcbbe24$var$C","assign","$a77485e72fcbbe24$var$D","$a77485e72fcbbe24$var$E","b","props","context","refs","updater","$a77485e72fcbbe24$var$F","$a77485e72fcbbe24$var$G","prototype","isReactComponent","setState","forceUpdate","$a77485e72fcbbe24$var$H","constructor","isPureReactComponent","$a77485e72fcbbe24$var$I","Array","isArray","$a77485e72fcbbe24$var$J","hasOwnProperty","$a77485e72fcbbe24$var$K","current","$a77485e72fcbbe24$var$L","key","ref","__self","__source","$a77485e72fcbbe24$var$M","d","c","k","h","g","arguments","length","children","f","m","defaultProps","$$typeof","type","_owner","$a77485e72fcbbe24$var$O","$a77485e72fcbbe24$var$P","$a77485e72fcbbe24$var$Q","replace","toString","$a77485e72fcbbe24$var$S","$a77485e72fcbbe24$var$R","push","next","done","value","String","keys","join","$a77485e72fcbbe24$var$T","_status","_result","then","$a77485e72fcbbe24$var$U","$a77485e72fcbbe24$var$V","transition","map","forEach","apply","count","toArray","only","ReactCurrentDispatcher","ReactCurrentBatchConfig","ReactCurrentOwner","_currentValue","_currentValue2","_threadCount","Provider","Consumer","_defaultValue","_globalName","_context","bind","render","_payload","_init","compare","useCallback","useContext","useDeferredValue","useEffect","useId","useImperativeHandle","useInsertionEffect","useLayoutEffect","useMemo","useReducer","useRef","useState","useSyncExternalStore","useTransition","$ca07057eef1ab6c2$export$e538f94cc8cf4db8","$ca07057eef1ab6c2$export$83d89fbfd8236492","$a189fc184070e3b9$exports","t","r","o","u","undefined","i","l","_dereq_","module1","global1","scheduleDrain","draining","Mutation","MutationObserver","WebKitMutationObserver","called","observer","nextTick","element","document","createTextNode","observe","characterData","data","setImmediate","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","setTimeout","channel","port1","onmessage","port2","postMessage","queue","oldQueue","len","task","immediate","INTERNAL","handlers","REJECTED","FULFILLED","PENDING","Promise1","resolver","TypeError","state","outcome","safelyResolveThenable","QueueItem","promise","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","returnValue","reject","resolve","getThen","obj","self1","thenable","onError","onSuccess","result","tryCatch","status","out","error","reason","all","iterable","values","resolved","allResolver","outValue","race","response","Promise","_typeof","idb","getIDB","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","createBlob","parts","properties","Blob","name","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","append","getBlob","Promise$1","executeCallback","callback","executeTwoCallbacks","errorCallback","normalizeKey","console","warn","getCallback","DETECT_BLOB_SUPPORT_STORE","supportsBlobs","dbContexts","READ_ONLY","READ_WRITE","_deferReadiness","dbInfo","dbContext","deferredOperation","deferredOperations","dbReady","_advanceReadiness","pop","_rejectReadiness","_getConnection","upgradeNeeded","createDbContext","db","close","dbArgs","version","openreq","open","onupgradeneeded","createObjectStore","storeName","oldVersion","ex","newVersion","onerror","preventDefault","onsuccess","onversionchange","target","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_decodeBlob","encodedBlob","_binStringToArrayBuffer","bin","buf","ArrayBuffer","arr","Uint8Array","charCodeAt","atob","_isEncodedBlob","__local_forage_encoded_blob","_fullyReady","_initReady","_dbInfo","createTransaction","mode","retries","tx","transaction","_tryReconnect","forages","forage","_getOriginalConnection","asyncStorage","_driver","_initStorage","options","ready","initPromises","ignoreErrors","j","slice","_defaultConfig","_support","isIndexedDBValid","isSafari","openDatabase","test","navigator","userAgent","platform","hasFetch","fetch","indexOf","IDBKeyRange","iterate","req","store","objectStore","openCursor","iterationNumber","cursor","getItem","setItem","_checkBlobSupport","_checkBlobSupportWithoutCaching","txn","blob","put","onabort","stopPropagation","oncomplete","matchedChrome","match","matchedEdge","parseInt","blobSupport","reader","FileReader","onloadend","btoa","readAsBinaryString","removeItem","clear","advanced","openKeyCursor","advance","dropInstance","currentConfig","config","dbPromise","isCurrentDb","dropObjectPromise","deleteObjectStore","_forage2","dropDBPromise","deleteDatabase","onblocked","_forage","BASE_CHARS","BLOB_TYPE_PREFIX_REGEX","SERIALIZED_MARKER","SERIALIZED_MARKER_LENGTH","TYPE_ARRAYBUFFER","TYPE_BLOB","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT16ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","TYPE_SERIALIZED_MARKER_LENGTH","toString$1","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","p","buffer","bytes","bufferToString","base64String","substring","localforageSerializer","serialize","valueType","marker","fileReader","onload","BLOB_TYPE_PREFIX","readAsArrayBuffer","JSON","stringify","deserialize","parse","blobType","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","createDbTable","executeSql","tryExecuteSql","sqlStatement","args","SYNTAX_ERR","results","rows","_setItem","retriesLeft","originalValue","serializer","sqlError","QUOTA_ERR","webSQLStorage","dbInfoPromise","description","size","item","storeNames","operationInfo","operations","dropTable","_getKeyPrefix","defaultConfig","keyPrefix","localStorageWrapper","checkIfLocalStorageThrows","localStorageTestKey","localStorage","isLocalStorageValid","keyPrefixLength","itemKey","includes","array","searchElement","x","isNaN","arg","DefinedDrivers","DriverSupport","DefaultDrivers","INDEXEDDB","WEBSQL","LOCALSTORAGE","DefaultDriverOrder","OptionalDriverMethods","LibraryMethods","concat","DefaultConfig","driver","extend","_key","localforage_js","LocalForage","driverTypeKey","_classCallCheck","instance","Constructor","driverName","defineDriver","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","driverObject","complianceError","driverMethods","driverMethodName","isRequired","configureMissingMethods","methodNotImplementedFactory","methodName","_i","_len","optionalDriverMethod","setDriverSupport","support","info","getDriver","getDriverPromise","getSerializer","serializerPromise","drivers","supportedDrivers","_getSupportedDrivers","setDriverToConfig","extendSelfWithDriver","_extend","oldDriverSetDone","currentDriverIndex","driverPromiseLoop","supports","libraryMethodsAndProperties","callWhenReady","localForageInstance","libraryMethod","_args","createInstance","$f86d19e70b42d506$var$FS_KEY","$fb1bb2d850b60f11$var$runtimeStorage","handles","$fb1bb2d850b60f11$var$installCaches","cache","caches","addAll","$fb1bb2d850b60f11$var$activate","delete","clients","claim","$fb1bb2d850b60f11$var$getActionAndResponse","query","handleMatches","isSameEntry","addEventListener","waitUntil","event","runFetch","request","clone","respondWith","message","source"],"version":3,"file":"sw.js.map"}